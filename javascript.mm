{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"L5EKO","rootPoint":{"objectClass":"CGPoint","x":1968,"y":22387.25},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"3U517","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"87ZYR","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"QKT11","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"33331","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"64Q83","lineColorHex":"#DC306C","text":"6. language：废弃\n7. src：包含要执行的代码的外部文件。\n8. type：表示代码块中脚本语言得内容类型（也叫MIME类型），这个值是\"text/javascript\"，如果是module，则代码会被当成ES6模块。JavaScript文件的MIME类型通常是\"application/x-javascript\"，不过给type属性这个值有可能导致脚本被忽略。"},"objectClass":"NSArray"},"text":"4. defer：表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。\n5. integrity：允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI,Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN, Content DeliveryNetwork）不会提供恶意内容。"},"objectClass":"NSArray"},"text":"有八个属性：\n1. async：可选。表示立即开始下载脚本，但不能阻止其他页面动作，只对外部脚本有效。\n2. charset：可选，使用src属性指定得代码字符集。\n3. crossorigin：配置相关请求得CORS（跨域资源共享）设置。默认不使用CORS。crossorigin=\"anonymous\"配置文件请求不必设置凭据标志。crossorigin=\"use-credentials\"设置凭据标志，意味着出站请求会包含凭据。"},"1":{"objectClass":"MindNode","ID":"VE13W","lineColorHex":"#DC306C","text":"注意：\n1. 在使用行内JS时，代码中不能出现</script>字符串，可以使用转义字符\"\\\"解决这个问题。\n2. 不管包含的代码是什么，浏览器都会按照<script>在页面中出现的顺序依次解释它们，前提是它们没有使用defer和async属性。第二个<script>元素的代码必须在第一个<script>元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。"},"2":{"objectClass":"MindNode","ID":"G2405","lineColorHex":"#DC306C","text":"标签位置：\n通常将JS引用放在<body>元素中的页面内容后面。处理JS代码之前可以完全渲染页面。"},"3":{"objectClass":"MindNode","ID":"85F38","lineColorHex":"#DC306C","text":"推迟执行脚本：\nHTML 4.01新增了一个defer属性。这个属性表示脚本在执行得时候不会改变页面得结构，脚本会被延迟到整个页面都解析完毕再运行。相当于告诉浏览器立即下载，但延迟执行。"},"4":{"objectClass":"MindNode","ID":"V1PNY","lineColorHex":"#DC306C","text":"动态加载脚本：\n通过想DOM中动态添加scipt元素同样可以加载指定得脚本。以这种方式获取的资源对浏览器预加载器是不可见的。可以在文档头部显示声明动态请求文件得存在：\nlink rel = \"preload\" href\"xxxxxx.js\""},"objectClass":"NSArray"},"text":"<script>元素"},"1":{"objectClass":"MindNode","ID":"N6Q5C","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2395D","lineColorHex":"#DC306C","text":"推荐使用外部文件，因为可维护性好，对于一个文件，用在多个页面只需下载一次有缓存。"},"objectClass":"NSArray"},"text":"行内代码与外部文件"},"2":{"objectClass":"MindNode","ID":"7T5Y3","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6X5RX","lineColorHex":"#DC306C","text":"可以使用doctype切换文档模式。文档模式有两种：混杂模式、标准模式。这两种模式主要区别在css渲染，但是会对JS有一些关联影响。"},"objectClass":"NSArray"},"text":"文档模式"},"3":{"objectClass":"MindNode","ID":"3D2W3","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"342B4","lineColorHex":"#DC306C","text":"用于给不支持JS得浏览器提供替代内容。它可以包含任何出现在body中得HTML元素，除script。一下两种情况满足一个就会渲染noscript中的内容：一、浏览器不支持脚本\n二、浏览器对脚本的支持关闭"},"objectClass":"NSArray"},"text":"<noscript>元素"},"objectClass":"NSArray"},"text":"HTML中的javascript"},"1":{"objectClass":"MindNode","ID":"MW91Y","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"GGG66","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"4K7CF","lineColorHex":"#BF58F5","text":"区分大小写：\nECMAScript中一切都区分大小写，变量、函数、操作符。"},"1":{"objectClass":"MindNode","ID":"J7H77","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"195YW","lineColorHex":"#BF58F5","text":"按照惯例，使用驼峰大小写形式，第一个单词小写后面每个单词首字母大写。"},"objectClass":"NSArray"},"text":"标识符：\n是变量、函数、属性、函数参数的名称。\n第一个字符必须是一个字母、下划线、美元符号。剩下的字符可以是字母下划线美元符号或者数字。"},"2":{"objectClass":"MindNode","ID":"89882","lineColorHex":"#BF58F5","text":"严格模式：\nES5增加的。在脚本开头加上一行\n\"use strict\"是个预处理指令。\n也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可"},"3":{"objectClass":"MindNode","ID":"3DHPQ","lineColorHex":"#BF58F5","text":"语句：\n可以不加分号，但推荐加分号，多行代码可以合并到一个代码块中。"},"objectClass":"NSArray"},"text":"语法"},"1":{"objectClass":"MindNode","ID":"7147S","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7VYYL","lineColorHex":"#BF58F5","text":"这些词汇不能用作标识符。"},"objectClass":"NSArray"},"text":"关键字和保留字"},"2":{"objectClass":"MindNode","ID":"435EN","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"4PV81","lineColorHex":"#BF58F5","text":"三种声明方式，var、let、const，在es6一书中已做备注，这里不再复述。\n在函数内部使用一个未声明的变量，会自动创建一个全局变量，不推荐这样做。"},"objectClass":"NSArray"},"text":"变量"},"3":{"objectClass":"MindNode","ID":"I0T86","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"238LU","lineColorHex":"#BF58F5","text":"typeof操作符，判断变量类型返回的是字符串。因为typeof是一个操作符而不是函数，所以不需要参数（但可以使用参数）。"},"1":{"objectClass":"MindNode","ID":"5P845","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"L7376","lineColorHex":"#BF58F5","text":"注意：一般来说永远不用显示的给某个变量设置undefined值。字面量undefined主要用于比较。\n\n对于声明了未赋值的变量还是未声明的变量，typeof都返回undefined。undefined是个假值。"},"objectClass":"NSArray"},"text":"Undefined类型：\nUndefined类型只有一个值，就是特殊值undefined。使用var或者let声明了但是没赋值就相当于赋值了undefined值。"},"2":{"objectClass":"MindNode","ID":"XT4T0","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"RCS2F","lineColorHex":"#BF58F5","text":"注意：\n1. 定义将来要保存对象值的变量时，使用null来初始化。\n2. undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等，用等于操作符（==）比较null和undefined始终返回true。"},"objectClass":"NSArray"},"text":"Null类型：\n也只有一个值，null。逻辑上null表示一个空对象指针，所以typeof会返回\"object\"。"},"3":{"objectClass":"MindNode","ID":"RT162","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"84P2X","lineColorHex":"#BF58F5","text":"将其他类型的值转换为布尔值，可以调用Boolean()转型函数，返回一个布尔值。if等流程控制语句会自动执行其他类型值转到布尔值。"},"objectClass":"NSArray"},"text":"Boolean类型：\n有两个字面量：true和false，两个布尔值不同于数值，所以true不等于1 false不等于0."},"4":{"objectClass":"MindNode","ID":"S3L5P","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"75WG6","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"NQW20","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"127Z6","lineColorHex":"#BF58F5","text":"NaN：\n它表示不是数值，任何涉及NaN的操作始终返回NaN（如NaN/10），在连续多步计算时这可能是个问题。其次，NaN不等于包括NaN在内的任何值。isNaN函数，会尝试把参数转换为数值。任何不能转换为数值的值都会导致这个函数返回true。在ECMAScript中，0、+0或-0相除会返回NaN"},"objectClass":"NSArray"},"text":"JS可以表示的最大数值，保存在Number.MAX_VALUE中，如果超出了可以表示的范围，会变成infinity值无穷。可以使用isInfinity函数判断是不是无穷大。"},"objectClass":"NSArray"},"text":"注意：\n定义浮点值，数值中一定要有小数点，小数点后至少有一个数字。因为ECMAScript总是想方设法把值转换为整数，即使小数点后跟着0比如1.0 都会转为整数。"},"objectClass":"NSArray"},"text":"Number类型：\n整数可以使用十进制、八进制、十六进制，八进制以0开头，十六进制以0x开头，八进制在严格模式下无效。会导致JavaScript引擎抛出语法错误。"},"5":{"objectClass":"MindNode","ID":"4G826","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"13740","lineColorHex":"#BF58F5","text":"Number（）函数转换规则：\nnull返回0、undefined返回NaN\n字符串：只有字符串是纯数字的时候，才能转为Number，其他都返回NaN。\n对象：调用valueOf方法，按照上述规则转换返回的值。如果转换结果是NaN，则调用toString()方法，再按照转换字符串的规则转换。"},"objectClass":"NSArray"},"text":"数值转换：\n有3个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。后面俩方法主要用于字符串。"},"6":{"objectClass":"MindNode","ID":"1K81P","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"D5BT3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1NF96","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"G59X4","lineColorHex":"#BF58F5","text":"toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。null和undefined值没有toString()方法。"},"objectClass":"NSArray"},"text":"3. ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串。\n4. 字符串插值：\n\n字符串插值通过在${}中使用一个JavaScript表达式实现。"},"objectClass":"NSArray"},"text":"注意：\n1.转义字符可以出现在字符串中的任何位置并且作为单个字符被解释。\n2. Es中的字符串是不可变的，定义初始化后值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量"},"objectClass":"NSArray"},"text":"String类型：\n字符串可以使用双引号单引号和反引号，但是不能混着用。"},"7":{"objectClass":"MindNode","ID":"21T34","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"D93A1","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"8D9RG","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"62OCW","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"IBRI5","lineColorHex":"#BF58F5","text":"5. 使用符号作为属性"},"objectClass":"NSArray"},"text":"4. 使用全局符号注册表：","markType":7},"objectClass":"NSArray"},"text":"2.按照规范，你只要创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。\n3. Symbol函数不能与new关键字一起作为构造函数使用。","maxWidthLine":306},"objectClass":"NSArray"},"text":"1.基本用法：\n需要使用Symbol（）函数初始化，typeof操作符返回symbol。可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关。"},"objectClass":"NSArray"},"text":"Symbol类型：\n符号是原始值，它的实例是唯一不可变的。通途是确保对象属性使用唯一标识符，不发生属性冲突。","maxWidthLine":307},"objectClass":"NSArray"},"text":"数据类型"},"4":{"objectClass":"MindNode","ID":"OWL2R","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"JN1U6","lineColorHex":"#BF58F5","text":"1.递增递减运算符：\n四个操作符可用作于任何值，\n对于字符串，如果是有效数值形式，则转换为数值再改变，如果是非有效数值，则将变量的值设置为NaN。\n对于对象，调用valueOf（）方法得到原始值，再执行上述方法。"},"1":{"objectClass":"MindNode","ID":"3752X","lineColorHex":"#BF58F5","text":"2. 一元加减\n如果将一元加应用到非数值，则会执行与使用Number()转型函数一样的类型转换：布尔值false和true转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的valueOf()和/或toString()方法以得到可以转换的值。"},"2":{"objectClass":"MindNode","ID":"BNIO1","lineColorHex":"#BF58F5","text":"位操作符","markType":7},"3":{"objectClass":"MindNode","ID":"8F271","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"0851X","lineColorHex":"#BF58F5","text":"|| 和 && 如果有操作数不是布尔值，不一定返回的是布尔值，他们会返回使逻辑表达式为true的那个操作数。"},"objectClass":"NSArray"},"text":"布尔操作符","markType":8},"4":{"objectClass":"MindNode","ID":"U3WRC","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"3OH21","lineColorHex":"#BF58F5","text":"乘法操作符：\n如果有任一操作数是NaN，则返回NaN。\n 如果是Infinity乘以0，则返回NaN。\n如果是Infinity乘以非0的有限数值，则根据第二个操作数的符号返回Infinity或-Infinity。\n如果是Infinity乘以Infinity，则返回Infinity。 如果有不是数值的操作数，则先在后台用Number()将其转换为数值，然后再应用上述规则。"},"objectClass":"NSArray"},"text":"乘性操作符：\n乘法、除法、取模。"},"5":{"objectClass":"MindNode","ID":"4654B","lineColorHex":"#BF58F5","text":"指数操作符：\nMath.pow() 这时方法，**这是操作符代表幂。"},"objectClass":"NSArray"},"text":"操作符"},"5":{"objectClass":"MindNode","ID":"RP8T7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"XJW25","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"37V49","lineColorHex":"#BF58F5","text":"for (const propName in person){\n    console.log(propName);\n}"},"objectClass":"NSArray"},"text":"1. for-in语句：\n一种严格的迭代语句，用于枚举对象中的非符号键属性，每次循环都会给自定义接受变量赋值一个person对象的属性作为值。如果迭代啊的变量是null或者undefined，则不执行循环体。","markType":7},"1":{"objectClass":"MindNode","ID":"N1V1E","lineColorHex":"#BF58F5","text":"2. for-of语句：\n用于遍历可迭代对象的元素。","markType":7},"2":{"objectClass":"MindNode","ID":"64DBU","lineColorHex":"#BF58F5","text":"3. 标签语句：\n语法：label:statement,start是一个标签，可以在后面通过break或continue语句引用。标签语句的典型应用场景是嵌套循环。","markType":7},"3":{"objectClass":"MindNode","ID":"98G1K","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"65288","lineColorHex":"#BF58F5","text":"使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利。严格模式不允许使用with语句，否则会抛出错误。"},"objectClass":"NSArray"},"text":"4.with语句\nwith语句的用途是将代码作用域设置为特定的对象，其语法是：with（expression）satement。"},"objectClass":"NSArray"},"text":"语句"},"6":{"objectClass":"MindNode","ID":"40NTL","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"JG46S","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"JT384","lineColorHex":"#BF58F5","text":"严格模式对函数也有一些限制：❑ 函数不能以eval或arguments作为名称；❑ 函数的参数不能叫eval或arguments；❑ 两个命名参数不能拥有同一个名称。如果违反上述规则，则会导致语法错误，代码也不会执行。"},"objectClass":"NSArray"},"text":"ES中函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句返回函数值。但是只要碰到return语句，函数就会立即停止执行并推出。这种用法最常用于提前终止函数执行。"},"objectClass":"NSArray"},"text":"函数"},"objectClass":"NSArray"},"text":"语言基础"},"2":{"objectClass":"MindNode","ID":"J2X27","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"72M76","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"DXKDW","lineColorHex":"#26BBFF","text":"2.动态属性：\n只有引用值可以添加属性，即动态属性。原始值不能有属性，尽管尝试给原始值添加属性不会报错。"},"1":{"objectClass":"MindNode","ID":"RQ5C1","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"VYXD6","lineColorHex":"#26BBFF","text":"将一个存储原始值的变量赋值给另一个变量，两个变量之间是相互独立的，虽然值一样。"},"1":{"objectClass":"MindNode","ID":"13K0R","lineColorHex":"#26BBFF","text":"引用值复制值区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象"},"objectClass":"NSArray"},"text":"3.复制值：\n除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。"},"2":{"objectClass":"MindNode","ID":"8HH95","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"J1VH6","lineColorHex":"#26BBFF","text":"就算是引用值，它保存的值是内存地址，所以按值传递的时候传的也是地址值，所以实参和形参会指向同一个内存地址的对象。"},"objectClass":"NSArray"},"text":"4.传递参数：\n所有函数都是按值传递的 。函数外的值会被赋值到函数内部 的参数中。所以实参和新参是互不干扰的对于原始值来说。但是对于引用值来说即使对象是按值传进函数的，obj也会通过引用访问对象。当函数内部给obj设置了name属性时，函数外部的对象也会反映这个变化，因为obj指向的对象保存在全局作用域的堆内存上。"},"3":{"objectClass":"MindNode","ID":"BCP85","lineColorHex":"#26BBFF","text":"5.确定类型：\ntypeof对于引用值的用处不大。ES提供了instanceOf操作符，可以判断变量是不是给定的引用类型。"},"objectClass":"NSArray"},"text":"原始值与引用值：\n原始值就是最简单的数据，引用值是由多个值构成的对象。保存原始值的变量是按值（byvalue）访问的，因为我们操作的就是存储在变量中的实际值。\n\n引用值是保存在内存中的对象。JS不允许直接访问内存位置，所以不能直接操作对象在的空间。操作对象实际上操作的是对该对象的引用。"},"1":{"objectClass":"MindNode","ID":"P1CZ1","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"3D41J","lineColorHex":"#26BBFF","text":"1.全局上下文是最外层的上下文。在浏览器中全局上下文是window对象，let和const声明的顶级变量不会定义在全局上下文中，但作用域解析上是一样的。"},"1":{"objectClass":"MindNode","ID":"P8GS3","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"UHUE3","lineColorHex":"#26BBFF","text":"上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。"},"objectClass":"NSArray"},"text":"2.每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。"},"2":{"objectClass":"MindNode","ID":"5FPL2","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"13B76","lineColorHex":"#26BBFF","text":"此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。"},"objectClass":"NSArray"},"text":"3.作用域链，决定上下文中的代码访问变量和函数的顺序，包含上下文相当于父级上下文，在当前上下文找不到的变量会去包含上下文中寻找，全局上下文的变量对象始终是作用域链的最后一个变量对象。"},"3":{"objectClass":"MindNode","ID":"036K3","lineColorHex":"#26BBFF","text":"4.作用域链增强：\n某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。\ntry/catch语句的catch块和with语句。"},"4":{"objectClass":"MindNode","ID":"8J8G5","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"DG416","lineColorHex":"#26BBFF","text":"标识符查找：\n当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。"},"objectClass":"NSArray"},"text":"5.变量声明：\nlet的块级作用域声明，块级作用域由最近的一对包含花括号{}界定，if块、while块、function块都是作用域。"},"objectClass":"NSArray"},"text":"执行上下文与作用域：\n变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。"},"2":{"objectClass":"MindNode","ID":"6IG9U","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"CF8OG","lineColorHex":"#26BBFF","text":"1.基本思路是先确定哪个变量不会再使用，然后释放它占用的内存，这个过程是周期性的。有两种主要的标记不再使用变量的方法：标记清理和引用计数。"},"1":{"objectClass":"MindNode","ID":"0W8F3","lineColorHex":"#26BBFF","text":"2.性能：\n现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。这些都会影响到性能。"},"2":{"objectClass":"MindNode","ID":"70736","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"6MC49","lineColorHex":"#26BBFF","text":"通过const和let声明提升性能：\n它们都以块为作用域，使用这两个新关键字可以更早的让垃圾回收程序介入。"},"1":{"objectClass":"MindNode","ID":"EK5PG","lineColorHex":"#26BBFF","text":"隐藏类和删除操作：","markType":7},"objectClass":"NSArray"},"text":"3.内存管理\n将内存占用量保持在一个较小的值可以让页面性能更好。"},"objectClass":"NSArray"},"text":"垃圾回收：","markType":7},"objectClass":"NSArray"},"text":"变量、作用域、内存","markType":9},"3":{"objectClass":"MindNode","ID":"87EX3","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"321MV","lineColorHex":"#37C45A","text":"引用值（对象）是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。"},"1":{"objectClass":"MindNode","ID":"TGZ62","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"2WB64","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"186BG","lineColorHex":"#37C45A","text":"let time = new Date(Date.parse(\"May 23,2019\"));"},"objectClass":"NSArray"},"text":"Date.parse()支持一下日期格式：\n“月/日/年”，如\"5/23/2019\"；\n”月名日，年”，如\"May 23, 2019\"；\n“周几 月名 日 年 时：分：秒 时区”，如\"Tue May 232019 00:00:00 GMT-0700\"；\n ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如2019-05-23T00:00:00（只适用于兼容ES5的实现）"},"1":{"objectClass":"MindNode","ID":"7P96O","lineColorHex":"#37C45A","text":"Date.UTC()方法也返回日期的毫秒表示，但使用的是跟Date.parse()不同的信息来生成这个值。传给Date.UTC()的参数是年、零起点月数（1月是0,2月是1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。"},"2":{"objectClass":"MindNode","ID":"6G3S8","lineColorHex":"#37C45A","text":"ECMAScript还提供了Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中"},"3":{"objectClass":"MindNode","ID":"P04D1","lineColorHex":"#37C45A","text":"日期格式化方法：\ntoDateString() toTimeString() toLocalDateString()具体的查文档！","markType":7},"objectClass":"NSArray"},"text":"1.Date类型\nDate类型将日期保存为自协调世界时间170年至今所经过的毫秒数。不给Date构造函数传参数的情况下，创建的对象保存的是当前日期。基于其他时间创建日期对象，提供了两个辅助方法Date.parse()和Date.UTC()，注意并不是实例方法,在创建构造函数时作为参数传入。"},"2":{"objectClass":"MindNode","ID":"4N8C5","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"1D0LC","lineColorHex":"#37C45A","text":"1. 正则表达式匹配模式标记：\ng：全局模式，表示查找字符串的全部内容，而不是找到第一个内容就结束。\ni：不区分大小写。\nm：多行模式，查找到一行文本末尾。\ny：黏附模式，只查找lastindex开始之后的字符串。\nu：Unicode模式\ns：dotAll模式，表示元字符，匹配任何字符。与其他语言中的正则表达式类似，所有元字符在模式中也必须转义。"},"1":{"objectClass":"MindNode","ID":"N3LL3","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"93KP2","lineColorHex":"#37C45A","text":"let pattern2 = new RegExp(\"[bc]at\",\"i\");"},"objectClass":"NSArray"},"text":"正则表达式也可以使用构造函数来创建，接受两个参数，模式字符串和标记字符串。"},"2":{"objectClass":"MindNode","ID":"4581V","lineColorHex":"#37C45A","text":"2. RegExp实例属性：\n每个RegExp实例都有下列属性，提供有关模式的各方面信息。书5.21"},"3":{"objectClass":"MindNode","ID":"5K464","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"DV739","lineColorHex":"#37C45A","text":"返回的数组虽然是Array的实例但包含两个额外的属性：index和input。index是字符串中匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。"},"1":{"objectClass":"MindNode","ID":"EKIQ8","lineColorHex":"#37C45A","text":"正则表达式的另一个方法是test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回true，否则返回false。"},"objectClass":"NSArray"},"text":"RegExp实例方法：\n主要方法是exec（），用于配合捕获组使用，只接受一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。"},"4":{"objectClass":"MindNode","ID":"4G2I1","lineColorHex":"#37C45A","text":"RegExp构造函数属性：\n查文档","markType":7},"objectClass":"NSArray"},"text":"2. RegExp类型\n支持正则表达式，let a = /pattern/flags，这时pattern模式可以是任何简单或复杂的正则表达式，可以带零个或多个flags，用于控制正则的行为。"},"3":{"objectClass":"MindNode","ID":"PV342","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"84Q03","lineColorHex":"#37C45A","text":"引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。意味着不能再运行时给原始值添加属性和方法。"},"1":{"objectClass":"MindNode","ID":"828DC","lineColorHex":"#37C45A","text":"1.Boolean\n创建boolean对象，使用构造函数时传入true或false。"},"2":{"objectClass":"MindNode","ID":"SNGBD","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"WR16N","lineColorHex":"#37C45A","text":"1.toFixed（）方法返回包含指定小数点位数的数值字符串。"},"1":{"objectClass":"MindNode","ID":"MJ87D","lineColorHex":"#37C45A","text":"2. toExponential（）返回以记数法表示的数值字符串。"},"2":{"objectClass":"MindNode","ID":"16135","lineColorHex":"#37C45A","text":"3. toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。"},"3":{"objectClass":"MindNode","ID":"1QO54","lineColorHex":"#37C45A","text":"4. ES6新增了Number.isInteger()方法，用于辨别一个数值是否保存为整数"},"objectClass":"NSArray"},"text":"2. Number\n提供了几个用于将数值格式化为字符串的方法。"},"3":{"objectClass":"MindNode","ID":"V7R2B","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"06CQJ","lineColorHex":"#37C45A","text":"1. charAt（）方法返回给定索引的字符"},"1":{"objectClass":"MindNode","ID":"31MN3","lineColorHex":"#37C45A","text":"2. 使用charCodeAt()方法可以查看指定码元的字符编码。比如c的A码的值为99就会返回这个值。"},"2":{"objectClass":"MindNode","ID":"34ZFV","lineColorHex":"#37C45A","text":"3. normalize（）方法\n可以使用normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：\"NFD\"、\"NFC\"、\"NFKD\"或\"NFKC\"。"},"3":{"objectClass":"MindNode","ID":"7U8J0","lineColorHex":"#37C45A","text":"4. concat（），用于将一个或多个字符串拼接成一个新字符串。"},"4":{"objectClass":"MindNode","ID":"2N648","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"U5OP5","lineColorHex":"#37C45A","text":"1、对slice()和substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。"},"1":{"objectClass":"MindNode","ID":"16YS1","lineColorHex":"#37C45A","text":"2、对substr()而言，第二个参数表示返回的子字符串长度。"},"2":{"objectClass":"MindNode","ID":"S4Q35","lineColorHex":"#37C45A","text":"当某个参数是负值时，这3个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字符串长度加上负参数值。而substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0。substring()方法会将所有负参数值都转换为0。"},"objectClass":"NSArray"},"text":"5. slice()、substr()和substring()。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。\n\n都不会修改调用他们的字符串。"},"5":{"objectClass":"MindNode","ID":"6D21T","lineColorHex":"#37C45A","text":"6.\n有两个方法用于在字符串中定位子字符串：indexOf()和lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。"},"6":{"objectClass":"MindNode","ID":"Q7RG8","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"70481","lineColorHex":"#37C45A","text":"它们的区别在于，startsWith()检查开始于索引0的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而includes()检查整个字符串"},"objectClass":"NSArray"},"text":"7. startsWith()、endsWith()和includes()\n检测是否包含另一个字符串，返回布尔值。"},"7":{"objectClass":"MindNode","ID":"36665","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"7T231","lineColorHex":"#37C45A","text":"这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。"},"objectClass":"NSArray"},"text":"8. trim（）方法\n这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。"},"objectClass":"NSArray"},"text":"3. String\n查看书籍","markType":7},"objectClass":"NSArray"},"text":"3. 原始值包装类型：\nES提供了三种特殊引用类型，Boolean、Number、String。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象。当以读模式访问原始值时，后台会执行三步：1.创建String类型实例2.调用实力上的方法3.销毁实例。这种行为可以让原始值拥有对象的行为（方法。"},"4":{"objectClass":"MindNode","ID":"59OCR","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"4FVUS","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"8RB2B","lineColorHex":"#37C45A","text":"2．Global对象属性\n所有引用类型构造函数，也都是Global对象的属性。"},"1":{"objectClass":"MindNode","ID":"55TT9","lineColorHex":"#37C45A","text":"3. window对象\n浏览器将window对象实现为Global对象的代理，因此，所有全局作用域中声明的变量和函数都变成了window的属性。"},"objectClass":"NSArray"},"text":"1. Global\neval方法（）这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。这个方法会将参数解释为实际的ES语句。"},"1":{"objectClass":"MindNode","ID":"C8P5G","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"Z429D","lineColorHex":"#37C45A","text":"1.Math对象属性\n用于保存数学中的一些特殊值。"},"1":{"objectClass":"MindNode","ID":"5XNUJ","lineColorHex":"#37C45A","text":"2. min（）和max（）方法\n用于确定一组数值中的最小值和最大值，这两个方法都接收任意多个参数。"},"2":{"objectClass":"MindNode","ID":"98N9B","lineColorHex":"#37C45A","text":"3. 舍入方法\n❑ Math.ceil()方法始终向上舍入为最接近的整数。\n❑ Math.floor()方法始终向下舍入为最接近的整数。\n❑ Math.round()方法执行四舍五入。\n❑ Math.fround()方法返回数值最接近的单精度（32位）浮点值表示。"},"3":{"objectClass":"MindNode","ID":"2MUM1","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"F856K","lineColorHex":"#37C45A","text":"number = Math.floor(Math.random()*total_number_of_choices+first_possible_value)"},"objectClass":"NSArray"},"text":"4．random()方法\nMath.random()方法返回一个0~1范围内的随机数，其中包含0但不包含1。这个函数始终返回小数。"},"objectClass":"NSArray"},"text":"2. Math"},"objectClass":"NSArray"},"text":"4.单列内置对象"},"objectClass":"NSArray"},"text":"基本引用类型","markType":9},"4":{"objectClass":"MindNode","ID":"0K6GP","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"DY4M6","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"46U97","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"58SF3","lineColorHex":"#1BD6E7","text":"对象字面量成为给函数传递大量可选参数的主要方式。只声明一个形参，接收一个对象字面量，通过新参.xxx的方式调用。"},"1":{"objectClass":"MindNode","ID":"92V2P","lineColorHex":"#1BD6E7","text":"最佳实践是，对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。"},"objectClass":"NSArray"},"text":"1. 创建Object实例有两种方式，1.使用 new Object（）构造函数 2. 对象字面量{ 属性名：属性值}。\n对象字面量中，属性名可以是字符串或数值，数值会自动转换成字符串。"},"1":{"objectClass":"MindNode","ID":"X73VG","lineColorHex":"#1BD6E7","text":"2. 属性的存取，一般使用.语法 还可以使用中括号来存取，但是括号内必须使用属性名的字符串形式，主要优势是可以通过变量访问属性。如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，也可以使用中括号语法"},"objectClass":"NSArray"},"text":"1. Object"},"1":{"objectClass":"MindNode","ID":"L6AKU","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"X38VU","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"53DGX","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"9B067","lineColorHex":"#1BD6E7","text":"Array.from()\n第一个参数是任何可迭代的解构。将其转换为数组，并作为返回值返回。还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用Array.from().map()那样先创建一个中间数组。"},"1":{"objectClass":"MindNode","ID":"00133","lineColorHex":"#1BD6E7","text":"Array.of()，\n可以把参数转换为数组。"},"objectClass":"NSArray"},"text":"Array构造函数还有两个ES6新增的用于创建数组的静态方法：Array.from()和Array.of()。from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实例。"},"objectClass":"NSArray"},"text":"1. 创建数组\n使用构造函数创建数组，new Array（）传入一个参数设置的是数组长度。如果这个值是其他类型的，则只会包含该特定值的数组。\n\n数组字面量创建 【xxx】。"},"1":{"objectClass":"MindNode","ID":"J5UH6","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"HBIW3","lineColorHex":"#1BD6E7","text":"ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异"},"objectClass":"NSArray"},"text":"2. 数组空位\n字面量初始化数组时，可以使用一串逗号来创建空位。ES6将这些空位当成元素，不过值为undefined。"},"2":{"objectClass":"MindNode","ID":"74QJO","lineColorHex":"#1BD6E7","text":"3. 数组索引\n数组length属性的独特之处在于，它不是只读的。通过修改length属性，可以从数组末尾删除或添加元素。如果将length设置为大于数组元素数的值，则新添加的元素都将以undefined填充。"},"3":{"objectClass":"MindNode","ID":"1FI0Q","lineColorHex":"#1BD6E7","text":"4. 检测数组\nisArray（）方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。"},"4":{"objectClass":"MindNode","ID":"P9WQ9","lineColorHex":"#1BD6E7","text":"5. 迭代器方法\nArray原型上暴露了三个用于检测数组内容的方法keys（）values（） entries（）。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而entries()返回索引/值对的迭代器。"},"5":{"objectClass":"MindNode","ID":"NE36F","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"R3C1W","lineColorHex":"#1BD6E7","text":"copyWithin（）：\ncopyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。"},"1":{"objectClass":"MindNode","ID":"N401V","lineColorHex":"#1BD6E7","text":"fill（）：使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始插入的位置索引是可选的。\n\nfill()静默忽略超出数组边界、零长度及方向相反的索引范围"},"objectClass":"NSArray"},"text":"6. 复制和填充方法\nES6新增了两个方法：批量复制方法copyWithin()，以及填充数组方法fill()。都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。","markType":7},"6":{"objectClass":"MindNode","ID":"O7N25","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"1C4HT","lineColorHex":"#1BD6E7","text":"toString（）和valueOf（）方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。\n\ntoLocalString（）方法和上面两个方法不一样的是，为了得到最终字符串，会调用数组每个值的toLocaleString()方法，而不是toString()方法。"},"objectClass":"NSArray"},"text":"7. 转换方法"},"7":{"objectClass":"MindNode","ID":"NTPT0","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"6S27Q","lineColorHex":"#1BD6E7","text":"push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则用于删除数组的最后一项，同时减少数组的length值，返回被删除的项。"},"objectClass":"NSArray"},"text":"8. 栈方法"},"8":{"objectClass":"MindNode","ID":"3WK33","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"XLD2B","lineColorHex":"#1BD6E7","text":"shift（）和unshift方法"},"objectClass":"NSArray"},"text":"9.队列方法"},"9":{"objectClass":"MindNode","ID":"Z9BEZ","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"LNM82","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"7V82D","lineColorHex":"#1BD6E7","text":"为此，sort()方法可以接收一个比较函数比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。"},"objectClass":"NSArray"},"text":"sort（）方法不传参数的时候，会在每一项上调用String()转型函数，然后比较字符串来决定顺序。根据ASCII值来比较。"},"objectClass":"NSArray"},"text":"10.排序方法"},"10":{"objectClass":"MindNode","ID":"C7IJ7","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"26XH6","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"617W6","lineColorHex":"#1BD6E7","text":"splice方法可以删除插入替换，插入和替换第二参数传0，第三个参数传要插入或者替换的值就行。\n\n始终返回它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）"},"objectClass":"NSArray"},"text":"concat（）方法用于连接组合数组。\n\n方法slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则slice()会返回该索引到数组末尾的所有元素。"},"objectClass":"NSArray"},"text":"11. 操作方法"},"objectClass":"NSArray"},"text":"2.Array"},"2":{"objectClass":"MindNode","ID":"S1LS2","lineColorHex":"#1BD6E7","text":""},"objectClass":"NSArray"},"text":"集合引用类型"},"5":{"objectClass":"MindNode","ID":"Y74P3","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"QP1VD","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"YWY55","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"TD61E","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"KY54O","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1J36G","lineColorHex":"#DC306C","text":"Object.defineProperty(person,\"name\",{\n    writable:false,\n    value:\"Jack\"\n})","summaries":{"0":{"objectClass":"NodeSummary","ID":"1MP3Y","text":"数据属性和访问器属性不能一起设置如果使用defineProperty方法","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"objectClass":"NSArray"},"text":"要修改属性的特性默认值必须使用Object.definePropert()方法，这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象 也就是前面的特性。\n\n如果修改了configurable特性为false后，再次调用Object.defineProperty()并修改任何非writable特性会导致错误\n\n在调用Object.defineProperty()时，configurable、enumerable和writable的值如果不指定，则都默认为false。","style2":{"objectClass":"NSDictionary","color":"#E2E1E1"}},"objectClass":"NSArray"},"text":"数据属性包含一个保存数据值的位置，读写都在这个位置，有四个特性描述它们的行为。\n1. [[Configurable]]:表示属性是否可以删除并重新定义，是否可以修改特性以及访问器属性。\n2. [[Enumerable]]:表示属性是否可以通过for-in循环。\n3.[[Writable]] 属性值是否可修改。\n4. [[Value]]包含属性实际值。默认值为undefined。"},"1":{"objectClass":"MindNode","ID":"46P3J","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1MP3Y","lineColorHex":"#DC306C","text":"访问器属性不能直接设置，要通过Object.definePropert()方法设置。这个方法是给对象添加属性或者修改属性的，第三个参数设置的是这个新增的属性的特性，get与set函数就在这里设置。如果给这个新属性赋值就会调用set函数。"},"1":{"objectClass":"MindNode","ID":"E45OG","lineColorHex":"#DC306C","text":"获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。"},"objectClass":"NSArray"},"text":"访问器属性：\n访问器属性不包含数据值，也就是没有赋值以及默认值的属性。\n它包含一个获取函数和设置函数即getter和setter。也有四个特性，前两个同数据属性一样。\n1.\n2.\n3. [[Get]]获取函数，读取数据时调用默认值为undefined。\n4. [[Set]]设置函数，写入属性时调用，默认值为undefined。"},"objectClass":"NSArray"},"text":"一、属性的类型\n属性分两种：数据属性和访问器属性","markType":7},"1":{"objectClass":"MindNode","ID":"34PM6","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2J5GU","lineColorHex":"#DC306C","text":"为此，ECMAScript提供了Object.define-Properties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。"},"objectClass":"NSArray"},"text":"二、定义多个属性\n在一个对象上同时定义多个属性的可能性是非常大的。"},"2":{"objectClass":"MindNode","ID":"IR302","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6VJT7","lineColorHex":"#DC306C","text":"Object.getOwnPropertyDescriptor()\n这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于不同 的属性类型，包含的属性不同。"},"1":{"objectClass":"MindNode","ID":"J4P50","lineColorHex":"#DC306C","text":"Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。"},"objectClass":"NSArray"},"text":"三、读取属性的特性\n使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。","markType":7},"3":{"objectClass":"MindNode","ID":"X1P0C","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"13694","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"548HS","lineColorHex":"#DC306C","text":"这个方法的原理是使用源对象的GET方法取得属性值，然后使用目标对象上的SET设置属性的值。\n\n对每个源对象执行的是浅复制，如果多个源对象有相同属性，则使用最后一个值。"},"1":{"objectClass":"MindNode","ID":"WA84E","lineColorHex":"#DC306C","text":"并且使用assign（）方法从源对象复制到目标对象的属性的特性是不会放生改变的，比如源对象的可写可遍历都是false，复制到目标对象上一样也是false。"},"objectClass":"NSArray"},"text":"ECMAScript 6专门为合并对象提供了Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）属性复制到目标对象。"},"objectClass":"NSArray"},"text":"四、合并对象\n就是把源对象所有的本地属性一起复制到目标对象上。这种操作也称为混合。"},"4":{"objectClass":"MindNode","ID":"ROR14","lineColorHex":"#DC306C","text":"五、对象标识及相等判定\n有些特殊的判断情况===是解决不了的，ES6提供了一个方法Object.is()，将要比较的值作为参数传进去即可。这个方法必须接收两个参数，就是要比较的值。"},"5":{"objectClass":"MindNode","ID":"512XS","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"WB115","lineColorHex":"#DC306C","text":"1.属性值简写\n在给对象添加变量的时候，属性名和变量名一样的时候，简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键"},"1":{"objectClass":"MindNode","ID":"C0D3G","lineColorHex":"#DC306C","text":"2. 可计算属性\n可计算属性之前，要使用变量作为对象的属性名，必须先创建对象然后再使用中括号语法，不能直接使用字面量动态命名属性。\n\n可计算属性，可以在对象字面量中也是使用中括号包变量名，告诉运行时将其作为JavaScript表达式求出变量值作为属性名。"},"2":{"objectClass":"MindNode","ID":"3KS5M","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"DW3I1","lineColorHex":"#DC306C","text":"简写方法名对获取函数和设置函数也是适用的。"},"objectClass":"NSArray"},"text":"3. 简写方法名\n方法名(参数){ }"},"objectClass":"NSArray"},"text":"六、增强的对象语法\nES6新增的语法糖"},"6":{"objectClass":"MindNode","ID":"P43BP","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"A3R8P","lineColorHex":"#DC306C","text":"简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。"},"1":{"objectClass":"MindNode","ID":"IFM4L","lineColorHex":"#DC306C","text":"使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。"},"objectClass":"NSArray"},"text":"7.对象解构"},"objectClass":"NSArray"},"text":"1. 理解对象"},"1":{"objectClass":"MindNode","ID":"0MWVP","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"N9X86","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"41TD1","lineColorHex":"#DC306C","text":"1. 在内存中创建对象\n2. 新对象内的[[prototype]]特性被赋值为构造函数的prototype属性！！！！\n3. 构造函数内部this指向新对象\n4. 执行构造函数代码\n5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。 \n\n创建的对象，都有一个constructor属性指向构造函数。"},"1":{"objectClass":"MindNode","ID":"BU4HG","lineColorHex":"#DC306C","text":"2. 构造函数也是函数\n任何函数只要使用new操作符调用就是构造函数，而不使用new操作符调用的函数就是普通函数。"},"2":{"objectClass":"MindNode","ID":"Q4DK5","lineColorHex":"#DC306C","text":"3. 构造函数的问题\n构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。"},"objectClass":"NSArray"},"text":"1. 构造函数模式\n注意事项！\n构造函数首字母大写。\n通过构造函数创建对象会执行几个操作"},"1":{"objectClass":"MindNode","ID":"3K6O0","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"GU3DC","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"D8S6E","lineColorHex":"#DC306C","text":"构造函数的原型对象即Person.prototype，是Object的实例对象，所以Person.prototype.__proto__ === Object.prototype"},"objectClass":"NSArray"},"text":"1. 首先构造函数也是函数所以他也有prototype属性，prototype属性指向的就是原型对象。也就可以将公共方法添加到prototype属性上。然后通过new Person（）构造函数创建对象的时候，新对象内的prototype属性被赋值为构造函数Person的prototype属性，所以Person的实例就都共享了原型对象上的方法。"},"1":{"objectClass":"MindNode","ID":"8675N","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1E198","lineColorHex":"#DC306C","text":"关键在于理解这一点：实例与构造函数原型之间有直接的联系_proto_，但实例与构造函数之间没有。"},"objectClass":"NSArray"},"text":"2. 理解原型\n在自定义构造函数时，原型对象默认只会获得constructor属性，其他的所有方法都继承自Object。Firefox、Safari和Chrome会在每个实例对象上暴露__proto__属性，通过这个属性可以访问对象的原型。\n\n正常的原型链会终止于Object原型对象，Object原型的原型是null。构造函数、原型对象、实例是三个完全不同的对象。"},"2":{"objectClass":"MindNode","ID":"Y7F3P","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"14627","lineColorHex":"#DC306C","text":"1. isPrototypeOf（）\n虽然不是所有实现都对外暴露了[[Prototype]]，但可以使用isPrototypeOf()方法确定两个对象之间的这种关系本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回true"},"1":{"objectClass":"MindNode","ID":"67229","lineColorHex":"#DC306C","text":"2. Object.getPrototypeOf()\n返回 参数的内部特性prototype的值。一般传一个实例对象。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要"},"2":{"objectClass":"MindNode","ID":"6P8PY","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"NC379","lineColorHex":"#DC306C","text":"setPrototypeOf（）可以传递两个参数，第一个参数是要修改的目标对象，第二个是新值对象，修改之后目标对象会拥有新值对象的属性并且原型对象就是这个新值。"},"objectClass":"NSArray"},"text":"3. setPrototypeOf（）可以向实例的私有特性prototype写入一个新值。用于重写一个对象的原型继承关系。 为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型"},"3":{"objectClass":"MindNode","ID":"I4Y8M","lineColorHex":"#DC306C","text":"\n5. Object.keys（）方法可以返回对象上所有可枚举的实例属性名称的字符串数组。\n\n6.如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()"},"objectClass":"NSArray"},"text":"有几个方法要记一下：\n注意！ECMAScript的Object.getOwnPropertyDescriptor()方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用Object.getOwnProperty-Descriptor()。"},"3":{"objectClass":"MindNode","ID":"4082H","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"VU1E1","lineColorHex":"#DC306C","text":"在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。这就是原型用于在多个对象实例间共享属性和方法的原理。"},"1":{"objectClass":"MindNode","ID":"ON240","lineColorHex":"#DC306C","text":"只能通过实例读取原型对象上的值，但不可能通过实例重写原型对象上的值。只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。可以使用delete删除实例上的属性，让编译器可以搜索到原型对象身上。","style2":{"objectClass":"NSDictionary","bold":0}},"2":{"objectClass":"MindNode","ID":"F1348","lineColorHex":"#DC306C","text":"4. hasOwnProperty（）用于确定某个属性是在实力上还是原型对象上。只有在实例上才返回true。传递的参数是属性名字符串。"},"objectClass":"NSArray"},"text":"原型层级"},"4":{"objectClass":"MindNode","ID":"1DNX6","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2E621","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"QCQ13","lineColorHex":"#DC306C","text":"function hasPrototypeProperty(object, name){\n    return !object.hasOwnProperty(name) && (name in object);\n}"},"1":{"objectClass":"MindNode","ID":"Q9Z22","lineColorHex":"#DC306C","text":"只要通过对象可以访问，in操作符就返回true，而hasOwnProperty()只有属性存在于实例上时才返回true。因此，只要in操作符返回true且hasOwnProperty()返回false，就说明该属性是一个原型属性。"},"objectClass":"NSArray"},"text":"单独使用：\nin操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上。"},"1":{"objectClass":"MindNode","ID":"48B7G","lineColorHex":"#DC306C","text":"for-in循环中使用in，通过对象访问且可以被枚举的属性都会返回，包括实例和原型属性。使用for-in遍历返回对象可枚举的属性名。"},"objectClass":"NSArray"},"text":"原型与in操作符：\n有两种方式使用in操作符：单独使用和在for-in循环中使用。"},"objectClass":"NSArray"},"text":"2. 原型模式\n每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。","markType":7},"2":{"objectClass":"MindNode","ID":"B29KB","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7RO7S","lineColorHex":"#DC306C","text":"这两个静态方法Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组。"},"objectClass":"NSArray"},"text":"对象迭代"},"3":{"objectClass":"MindNode","ID":"BQRDT","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"WNFYG","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"DYYJD","lineColorHex":"#DC306C","text":"可以在对象字面量中，增加constructor属性指向构造函数但是这个属性原本是不可遍历的，所以还需要使用到defineProperty方法（）"},"1":{"objectClass":"MindNode","ID":"S9H76","lineColorHex":"#DC306C","text":"重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。"},"objectClass":"NSArray"},"text":"1. \n原型对象也可以使用对象字面量，但是这完全重写了当初创建构造函数时的原型对象， 使得原型对象的constructor不再指向构造函数，而是Object构造函数。"},"1":{"objectClass":"MindNode","ID":"A00B9","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"UX2DE","lineColorHex":"#DC306C","text":"通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。"},"objectClass":"NSArray"},"text":"2. 原生对象原型\n原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。"},"objectClass":"NSArray"},"text":"其他原型语法"},"objectClass":"NSArray"},"text":"2. 创建对象\n创建具有同样接口的多个对象需要重复编写很多代码。","markType":7},"2":{"objectClass":"MindNode","ID":"GRO13","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"XI5T7","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"8S896","lineColorHex":"#DC306C","text":"基本思想：\n子类的原型指向父类的实例，所以这个子类的原型也有一个指针指向另一个原型。"},"1":{"objectClass":"MindNode","ID":"E6I2F","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"O6TS4","lineColorHex":"#DC306C","text":"SubType.prototype = new SuperType();现在SubType的原型是Super Type的实例对象，重写了SubType的原型这就意味着Super type实例对象可以访问的所有属性和方法，现在都存在于SubType的原型对象上。  关键在于Subtype没有使用默认原型，而是将其转换成立一个新的对象。"},"1":{"objectClass":"MindNode","ID":"D8FB0","lineColorHex":"#DC306C","text":"let instance = new SubType();  instance内部的[[Prototype]]指向的是Subtype.prototype,而SubType.prototype（作为SuperType的实例又通过内部的[[Prototype]]）指向SuperType.prototype。"},"2":{"objectClass":"MindNode","ID":"L3R7J","lineColorHex":"#DC306C","text":"由于SubType.prototype的constructor属性被重写为指向SuperType，所以instance.constructor也指向SuperType。"},"objectClass":"NSArray"},"text":"一个例子！！有两个类 SuperType和Subtype"},"2":{"objectClass":"MindNode","ID":"SY98R","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2B94T","lineColorHex":"#DC306C","text":"实际上，原型链中还有一环。默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的。"},"objectClass":"NSArray"},"text":"1. 默认原型"},"3":{"objectClass":"MindNode","ID":"7541Y","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"4JOW5","lineColorHex":"#DC306C","text":"第一种方式是使用instanceof操作符，如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true。"},"1":{"objectClass":"MindNode","ID":"78483","lineColorHex":"#DC306C","text":"确定这种关系的第二种方式是使用isPrototypeOf()方法。"},"objectClass":"NSArray"},"text":"2. 原型与继承关系"},"4":{"objectClass":"MindNode","ID":"0V60T","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"8NC2Y","lineColorHex":"#DC306C","text":"子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。  重写父类方法的主要思想就是，因为子类的原型是父类的实例对象所以在子类的原型上写父类原型对象上已有的方法就会遮蔽父类原型对象上的方法。"},"1":{"objectClass":"MindNode","ID":"1E6O7","lineColorHex":"#DC306C","text":"另一个要理解的重点是，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。"},"objectClass":"NSArray"},"text":"3. 关于方法"},"5":{"objectClass":"MindNode","ID":"3CBT7","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"S15HC","lineColorHex":"#DC306C","text":"主要问题出现在原型中包含引用值的时候。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。 比如父类定义了实例属性，子类继承了父类之后这些实例属性存在于子类的原型对象上，子类实例化一个对象之后可以通过原型链访问到这些属性，一旦一个子类的实例改变了这些属性，后面再实例化的对象也会应用这些改变。"},"1":{"objectClass":"MindNode","ID":"KQ8OY","lineColorHex":"#DC306C","text":"原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。"},"objectClass":"NSArray"},"text":"4. 原型链的问题"},"objectClass":"NSArray"},"text":"3.1 原型链","markType":7},"1":{"objectClass":"MindNode","ID":"C2IV6","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"VY9XW","lineColorHex":"#DC306C","text":"为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。"},"1":{"objectClass":"MindNode","ID":"898G3","lineColorHex":"#DC306C","text":"基本思路很简单：在子类构造函数中调用父类构造函数。所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。这样就解决了原型继承共用了引用值的问题，每个实例都会有自己的属性。"},"2":{"objectClass":"MindNode","ID":"4RW1S","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"4K87K","lineColorHex":"#DC306C","text":"相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。"},"objectClass":"NSArray"},"text":"1. 传递参数"},"3":{"objectClass":"MindNode","ID":"MU5S9","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"DY7MM","lineColorHex":"#DC306C","text":"盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。"},"objectClass":"NSArray"},"text":"2. 问题"},"objectClass":"NSArray"},"text":"3.2 盗用构造函数"},"2":{"objectClass":"MindNode","ID":"5QB38","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"YG5PQ","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"BM8SD","lineColorHex":"#DC306C","text":"基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式。"},"objectClass":"NSArray"},"text":"综合了原型链和盗用构造函数，将两者的优点集中了起来。"},"objectClass":"NSArray"},"text":"3.3 组合继承"},"objectClass":"NSArray"},"text":"3. 继承\n实现继承是ES唯一支持的继承方式，通过原型链实现。"},"3":{"objectClass":"MindNode","ID":"NSFRA","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"VCAUF","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"YO28Y","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7055C","lineColorHex":"#DC306C","text":"在类的内部可以通过name属性访问类的名称。但是不能在类的外部访问类名标识符。"},"objectClass":"NSArray"},"text":"类的构成：\n类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。"},"objectClass":"NSArray"},"text":"4.1 类的定义\n有两种主要方式：类声明和类表达式\n类声明：calss Person{}\n类表达式： const Animal = class{}\n\n类定义不会提升。函数受函数作用域限制，而类受块作用域限制。"},"1":{"objectClass":"MindNode","ID":"70THJ","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"0105M","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"JUK7Z","lineColorHex":"#DC306C","text":"类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符。而普通构造函数如果不使用new调用，那么就会以全局的this（通常是window）作为内部对象。调用类构造函数时如果忘了使用new则会抛出错误"},"objectClass":"NSArray"},"text":"1. 实例化\n首先在内存创建一个对象，并把新对象内部的[[prototype]]设置为构造函数的prototype，构造函数内部的this被赋值为这个新对象，指向构造函数内部的代码，最后返回这个对象。"},"1":{"objectClass":"MindNode","ID":"LJ6Z3","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"06378","lineColorHex":"#DC306C","text":"类本身在使用new调用时，就会被当成构造函数，类中定义的constructor方法不会当成构造函数。如果直接使用类中的constructor当成普通构造函数，instanceof 可以返回true。"},"objectClass":"NSArray"},"text":"2. 把类当作特殊的函数"},"objectClass":"NSArray"},"text":"4.2 类的构造函数\nconstructor关键字用于在类定义块内部创建类的构造函数。告诉解释器在使用new操作符创建类实例时，调用构造函数，不定义构造函数相当于定义为空函数。"},"2":{"objectClass":"MindNode","ID":"267X4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"H7J6T","lineColorHex":"#DC306C","text":"1. 实例成员\n每次通过new调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。构造函数执行完毕周还可以继续添加新成员。\n\n每个实例都对应一个唯一的成员对象，所有成员不会再原型上共享。"},"1":{"objectClass":"MindNode","ID":"YQA64","lineColorHex":"#DC306C","text":"2. 原型方法和访问器\n为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。\n可以把方法定义在类构造函数中，或者类块中，但不能在类块中为原型添加原始值或对象作为成员数据。\n\n类定义也支持获取和设置访问器。语法与行为跟普通对象一样"},"2":{"objectClass":"MindNode","ID":"SBKBC","lineColorHex":"#DC306C","text":"3. 静态类方法\n这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。 \n使用static关键字作为前缀，静态成员中，this引用类自身。"},"3":{"objectClass":"MindNode","ID":"81881","lineColorHex":"#DC306C","text":"4. 非函数原型和类成员\n虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加。"},"4":{"objectClass":"MindNode","ID":"T084W","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"E23H3","lineColorHex":"#DC306C","text":"派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。"},"objectClass":"NSArray"},"text":"5. 继承\nES6类支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。","markType":7},"5":{"objectClass":"MindNode","ID":"N4050","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"E311T","lineColorHex":"#DC306C","text":"new.target保存通过new关键字调用的类或者函数，在实例化时检测new.target是不是抽象基类，组织抽象基类实例化。"},"objectClass":"NSArray"},"text":"6. 抽象基类\n有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript没有专门支持这种类的语法，但通过new.target也很容易实现。"},"objectClass":"NSArray"},"text":"4.3 实例、原型、类成员"},"objectClass":"NSArray"},"text":"4. 类\n虽然ECMAScript 6类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。","maxWidthLine":306},"objectClass":"NSArray"},"text":"对象、类、面向对象编程","markType":9},"6":{"objectClass":"MindNode","ID":"F6A1Y","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"PW85Q","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"WRV10","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"32N4M","lineColorHex":"#DC306C","text":"箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性。"},"objectClass":"NSArray"},"text":"使用=>语法定义函数表达式的能力。只有一个参数可以不用括号，没有参数或者有多个参数的时候才需要使用括号。\n\n箭头函数也可以不使用大括号，但是只能包含一条代码。"},"objectClass":"NSArray"},"text":"箭头函数"},"1":{"objectClass":"MindNode","ID":"9Q4TB","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6665U","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"3S1U2","lineColorHex":"#DC306C","text":"如果函数是一个获取函数、设置函数，或者使用bind()实例化，那么标识符前面会加上一个前缀"},"objectClass":"NSArray"},"text":"函数名就是指向函数的指针，ES6所有函数对象都会暴露一个只读的name属性，多数情况下保存的是字符串化的变量名。没有名称也显示空字符串，Function构造函数创建的，则会标识anonymous。"},"objectClass":"NSArray"},"text":"函数名"},"2":{"objectClass":"MindNode","ID":"WGH4D","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"3O8OR","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"JT1MO","lineColorHex":"#DC306C","text":"arguments对象是一个类数组对象（但不是Array的实例），因此可以使用中括号语法访问其中的元素（第一个参数是arguments[0]，第二个参数是arguments[1]）。而要确定传进来多少个参数，可以访问arguments.length属性。"},"1":{"objectClass":"MindNode","ID":"87OGB","lineColorHex":"#DC306C","text":"可以通过判断arguments.length来执行不同的函数体，虽然不像真正的函数重载那么明确，但这已经足以弥补ECMAScript在这方面的缺失了。"},"2":{"objectClass":"MindNode","ID":"MEMW4","lineColorHex":"#DC306C","text":"arguments对象的值始终会与对应命名参数的值同步，但在严格模式下不会。"},"objectClass":"NSArray"},"text":"ES函数不关心传入函数的个数，因为函数的参数在内部表现为一个数组，函数调用时总接收一个数组。可以在函数内部访问arguments对象，从中取得传进来的每个参数值。"},"1":{"objectClass":"MindNode","ID":"5MOJ0","lineColorHex":"#DC306C","text":"箭头函数中的参数：\n如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的命名参数访问"},"objectClass":"NSArray"},"text":"理解参数"},"3":{"objectClass":"MindNode","ID":"K4X14","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1Y275","lineColorHex":"#DC306C","text":"ES6定义两个同名函数，后定义的会覆盖先定义的，不存在重载。\n\n前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。"},"objectClass":"NSArray"},"text":"没有重载"},"4":{"objectClass":"MindNode","ID":"K457R","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"219E7","lineColorHex":"#DC306C","text":"在函数定义中的参数后面用=赋值一个默认值。当传入参数为undefined时，使用默认值。在使用默认值时，arguments对象的值不反应参数的默认值。"},"1":{"objectClass":"MindNode","ID":"L74UO","lineColorHex":"#DC306C","text":"默认参数不限于原始值或对象类型，可以使用调用函数返回的值。\n函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。"},"2":{"objectClass":"MindNode","ID":"232YE","lineColorHex":"#DC306C","text":"参数初始化顺序遵循暂时性死区规则，前面定义的参数不能引用后面定义的。也存在自己的作用域，不能引用函数体的作用域。"},"objectClass":"NSArray"},"text":"默认参数值"},"5":{"objectClass":"MindNode","ID":"G81QB","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"FRTK0","lineColorHex":"#DC306C","text":"1. 扩展参数\n对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。"},"1":{"objectClass":"MindNode","ID":"TV2N5","lineColorHex":"#DC306C","text":"2. 收集参数\n可以使用扩展操作符把不同长度的独立参数组合为一个数组。但是在函数定义中，只能将它作为最后一参数。使用收集参数并不影响arguments对象，传进来几个arguments的length就是几。"},"objectClass":"NSArray"},"text":"参数扩展与收集"},"6":{"objectClass":"MindNode","ID":"4014V","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"948OV","lineColorHex":"#DC306C","text":"JS在任何代码执行之前，就会先读取函数声明，并在执行上下文中生成函数定义，这就是函数声明提升。函数表达式就不行，因为包裹在一个变量初始化语句中，不会提升。"},"objectClass":"NSArray"},"text":"函数声明与函数表达式"},"7":{"objectClass":"MindNode","ID":"CM0M7","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5TXPK","lineColorHex":"#DC306C","text":"可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。"},"objectClass":"NSArray"},"text":"函数作为值"},"8":{"objectClass":"MindNode","ID":"S4T9K","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"JP41K","lineColorHex":"#DC306C","text":"ES5中函数内部存在两个特殊值arguments和this，ES6新增了new.target"},"1":{"objectClass":"MindNode","ID":"6AI1U","lineColorHex":"#DC306C","text":"1. arguments\n它是包含调用函数时传入的所有参数的一个类数组对象。只有以function关键字定义函数才有，它有一个callee属性，是一个指向arguments对象所在函数的指针。"},"2":{"objectClass":"MindNode","ID":"N16BQ","lineColorHex":"#DC306C","text":"2. this\n在标准函数中，this引用的是把函数当成方法调用的上下文对象，全局上文调用函数时this指向windows。\n\n在箭头函数中，this引用的是定义箭头函数的上下文。事件回调或定时回调中调用某个函数时，this值指向的并非想要的对象，用箭头函数可以解决。"},"3":{"objectClass":"MindNode","ID":"V425H","lineColorHex":"#DC306C","text":"3. caller\n这个属性引用的是调用当前函数的函数"},"4":{"objectClass":"MindNode","ID":"E75G0","lineColorHex":"#DC306C","text":"4. new.target\nECMAScript 6新增了检测函数是否使用new关键字调用的new.target属性。如果函数是正常调用的，则new.target的值是undefined；如果是使用new关键字调用的，则new.target将引用被调用的构造函数。"},"objectClass":"NSArray"},"text":"函数内部"},"9":{"objectClass":"MindNode","ID":"SOF64","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6D122","lineColorHex":"#DC306C","text":"函数也是对象，所有也有属性和方法。每个函数都有两个属性：length和prototype。length属性保存函数定义的命名参数个数。\nprototype是保存引用类型所有实例方法的地方。"},"1":{"objectClass":"MindNode","ID":"GI5I1","lineColorHex":"#DC306C","text":"apply（）和call（）方法。这两个方法都会以指定的this值来调用函数，就是会设置调用函数时函数内部this对象的值。apply()方法接收两个参数：函数内this的值和一个参数数组。\n\ncall（）方法第一个参数跟apply()一样，也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。"},"2":{"objectClass":"MindNode","ID":"2R8NI","lineColorHex":"#DC306C","text":"ES5定义了一个方法bind（），bind()方法会创建一个新的函数实例，其this值会被绑定到传给bind()的对象。"},"objectClass":"NSArray"},"text":"函数属性与方法"},"10":{"objectClass":"MindNode","ID":"FY17V","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"57Z15","lineColorHex":"#DC306C","text":"let a = function(arg0,arg1)\n这样创建的函数叫做匿名函数，因为function关键字没有标识符，如果未赋值给其他变量的匿名函数的name属性是空字符串。\n\n理解函数声明与函数表达式之间的区别，关键是理解提升。"},"objectClass":"NSArray"},"text":"函数表达式"},"11":{"objectClass":"MindNode","ID":"YDL4D","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"D07HJ","lineColorHex":"#DC306C","text":"递归函数通常的形式是一个函数通过名称调用自己。"},"objectClass":"NSArray"},"text":"递归"},"12":{"objectClass":"MindNode","ID":"W77F2","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"BLRAB","lineColorHex":"#DC306C","text":"具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。\nfunction a(){ return function b()}\n\n这种情况下无论调用多少次嵌套函数，都只有一个栈帧。"},"objectClass":"NSArray"},"text":"尾调用优化"},"13":{"objectClass":"MindNode","ID":"IUHD9","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"47XQ7","lineColorHex":"#DC306C","text":"闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。"},"1":{"objectClass":"MindNode","ID":"48UAK","lineColorHex":"#DC306C","text":"函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。"},"2":{"objectClass":"MindNode","ID":"VWGN8","lineColorHex":"#DC306C","text":"闭包：在一个函数内部定义的函数会把外部函数的活动对象添加到自己的作用域链中。内部函数的作用域链就有两个活动对象和一个变量对象，因此外部函数的活动对象不能在外部函数执行完毕的时候销毁，只有当内部函数销毁时才能销毁，可能会造成内存泄漏。"},"objectClass":"NSArray"},"text":"闭包","markType":7},"objectClass":"NSArray"},"text":"函数"},"7":{"objectClass":"MindNode","ID":"PHRUM","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"WL53S","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"01G5P","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2CW24","lineColorHex":"#BF58F5","text":"回调函数的目的是，给异步操作提供一个函数以返回这个异步操作的结果。"},"objectClass":"NSArray"},"text":"1、同步与异步\n同步行为对应内存中顺序执行的处理器指令。每条指令都严格按照出现的顺序来执行。\n\n异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。如果程序需要异步操作的某个值，需要等待异步执行的函数更新这个值并通知程序。"},"1":{"objectClass":"MindNode","ID":"3S316","lineColorHex":"#BF58F5","text":"2. 以往的异步编程模式\n串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。\n有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码"},"objectClass":"NSArray"},"text":"1. 异步编程"},"1":{"objectClass":"MindNode","ID":"5VH52","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"18H0L","lineColorHex":"#BF58F5","text":"异步函数，也称为“async/await”（语法关键字）"},"1":{"objectClass":"MindNode","ID":"36574","lineColorHex":"#BF58F5","text":"1. async\nasync关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。\n\n不过，异步函数如果使用return关键字返回了值（如果没有return则会返回undefined），这个值会被Promise.resolve()包装成一个期约对象。"},"objectClass":"NSArray"},"text":"2.异步函数"},"2":{"objectClass":"MindNode","ID":"LXF1U","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"OKK26","lineColorHex":"#BF58F5","text":"创建promise实例必须有一个执行器函数，promise对象一共有三种状态，pending、resolve、rejected。在执行器函数中分别调用resolved或者rejected可以改变promise对象的状态为成功或者失败，此时就会有值和理由默认值是undefined，由resolved和rejected回调函数传给then方法。"},"1":{"objectClass":"MindNode","ID":"BC9C4","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"G8114","lineColorHex":"#BF58F5","text":"对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。相当于由Promise.resolve（promise）生成的这Promise实例是和传进去的参数期约是一样的。"},"objectClass":"NSArray"},"text":"1. promise.resolve()\n调用该静态方法可以实例化一个解决的期约对象。这个解决的期约的值对应着传给Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约","maxWidthLine":306},"2":{"objectClass":"MindNode","ID":"6023M","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"77CC3","lineColorHex":"#BF58F5","text":"Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过try/catch捕获，而只能通过拒绝处理程序捕获）"},"1":{"objectClass":"MindNode","ID":"3H62E","lineColorHex":"#BF58F5","text":"如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由："},"objectClass":"NSArray"},"text":"2.Promise.rejected()\n与上面的方法很像。"},"3":{"objectClass":"MindNode","ID":"7O1SY","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"8NI8H","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"F3453","lineColorHex":"#BF58F5","text":"这个新期约实例也可以当作Promise.resolve()之后的期约。所以当处理程序返回的是一个期约时，根据Promise.reslove的幂等性，新的期约实例就是这个返回的期约。"},"objectClass":"NSArray"},"text":"Promise.prototype.then()方法返回一个新的期约实例。这个新期约实例是基于onReslove的返回值构建的，返回值也就是解决值。如果没有这个处理程序，则Promise.reslove()包装上一个期约解决值作为这个新期约的解决值。"},"1":{"objectClass":"MindNode","ID":"P323G","lineColorHex":"#BF58F5","text":"如果没有显式的返回语句，则Promise.resolve()会包装默认的返回值undefined。"},"2":{"objectClass":"MindNode","ID":"7TGI8","lineColorHex":"#BF58F5","text":"onRejected处理程序返回的值也会被Promise.resolve()包装。乍一看这可能有点违反直觉，但是想一想，onRejected处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。"},"objectClass":"NSArray"},"text":"3. Promise.prototype.then()\n是为期约实例添加处理程序的主要方法。接受两个函数作为参数，在期约进入成功或者失败的时候执行。给then方法传非函数类型的参数会自动忽略。"},"4":{"objectClass":"MindNode","ID":"GLDWG","lineColorHex":"#BF58F5","text":"4. Promise.prototype.catch\n调用它就相当于调用Promise.prototype. then(null,onRejected)"},"5":{"objectClass":"MindNode","ID":"9O0FK","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"ZKT52","lineColorHex":"#BF58F5","text":"这个方法在期约是解决或拒绝时都会执行，所以主要用于清理代码。返回一个新的期约实例。"},"1":{"objectClass":"MindNode","ID":"5SFHN","lineColorHex":"#BF58F5","text":"因为onFinally被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。也就是，父期约是什么状态什么解决值，它就是什么。"},"objectClass":"NSArray"},"text":"5. Promise.finally"},"6":{"objectClass":"MindNode","ID":"57S1W","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5P7J8","lineColorHex":"#BF58F5","text":"在执行函数中，解决的值和拒绝的理由是分别作为resolve()和reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为onResolved或onRejected处理程序的唯一参数。"},"1":{"objectClass":"MindNode","ID":"N2AN8","lineColorHex":"#BF58F5","text":"这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。"},"objectClass":"NSArray"},"text":"6. 传递解决值和拒绝值"},"7":{"objectClass":"MindNode","ID":"R35FU","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"WGU88","lineColorHex":"#BF58F5","text":"异步错误只能通过异步的onRejected处理程序捕获。不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用try/catch在执行函数中捕获错误"},"objectClass":"NSArray"},"text":"7. 拒绝期约与拒绝错误处理\n在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。"},"objectClass":"NSArray"},"text":"3. promise"},"objectClass":"NSArray"},"text":"期约与异步函数","markType":5},"8":{"objectClass":"MindNode","ID":"3CMII","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"595J0","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"3551C","lineColorHex":"#26BBFF","text":"1. Global作用域\n使用var定义在全局作用域下的变量、函数都会自动成为window对象的成员。用let、const声明的不会添加到window对象中。"},"1":{"objectClass":"MindNode","ID":"J265E","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"4UE99","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"Q7132","lineColorHex":"#26BBFF","text":"可以使用moveTo()和moveBy()方法移动窗口。这两个方法都接收两个参数，其中moveTo()接收要移动到的新位置的绝对坐标x和y；而moveBy()则接收相对当前位置在两个方向上移动的像素数。"},"objectClass":"NSArray"},"text":"现代浏览器提供了screenLeft和screenTop属性，用于表示窗口相对于屏幕左侧和顶部的位置，返回值的单位是CSS像素。"},"objectClass":"NSArray"},"text":"2.窗口关系\ntop对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而parent对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则parent等于top（都等于window）。\n还有一个self对象，它是终极window属性，始终会指向window。\n\n这些都是window对象的属性，窗口就是整个浏览器！！！"},"2":{"objectClass":"MindNode","ID":"L8R1S","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"FVO03","lineColorHex":"#26BBFF","text":"可以使用resizeTo()和resizeBy()方法调整窗口大小。这两个方法都接收两个参数，resizeTo()接收新的宽度和高度值，而resizeBy()接收宽度和高度各要缩放多少。"},"objectClass":"NSArray"},"text":"3. 窗口大小\n支持四个属性，innerWidth、innerHeight、outerWidth、outerHeight。前两个返回的是窗口页面视口大小，后两个是返回浏览器窗口自身大小也就是整个浏览器。\n\ndocumentElement.clientHeight/clientWidth返回的是元素渲染在页面时的实际大小。"},"3":{"objectClass":"MindNode","ID":"W5QPO","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"Y767O","lineColorHex":"#26BBFF","text":"1、\n度量文档相对于视口滚动的属性有两对，返回相等的值：window.pageXoffset/window.scrollX和window.pageYoffset/window.scrollY。\n\n也就是返回浏览器滑块移动的距离是多少，分为横向和纵向。"},"1":{"objectClass":"MindNode","ID":"U665K","lineColorHex":"#26BBFF","text":"2、 可以使用scroll（）、scrollTo（）和scrollBy（）方法滚动页面。这3个方法都接收表示相对视口距离的x和y坐标，这两个参数在前两个方法中表示要滚动到的坐标。还可以接收字典ScrollToOptions\nwindow.scrollTo({left:xx,top:xx,behavior})"},"objectClass":"NSArray"},"text":"4. 视口位置\n浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。"},"4":{"objectClass":"MindNode","ID":"MP7VU","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"8N73F","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"2XEGO","lineColorHex":"#26BBFF","text":"1、\n如果window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页来显示对应URL的页面。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top或_blank。"},"1":{"objectClass":"MindNode","ID":"TPNNV","lineColorHex":"#26BBFF","text":"2、 \n第三个参数特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。注意是打开新的窗口！！！"},"2":{"objectClass":"MindNode","ID":"882H2","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"44UHQ","lineColorHex":"#26BBFF","text":"把opener设置为null表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。这个连接一旦切断，就无法恢复了。"},"objectClass":"NSArray"},"text":"3、 \nopen方法会返回一个新建窗口的引用。这个对象与普通window对象没有区别。新创建窗口的window对象有一个属性opener，指向打开它的窗口。"},"objectClass":"NSArray"},"text":"window.open()方法可以用于导航到指定的URL，也可以用于打开新窗口。这个方法接收4个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。"},"1":{"objectClass":"MindNode","ID":"V26EM","lineColorHex":"#26BBFF","text":"4、 弹窗屏蔽程序\n所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。window.open()就可能返回null。"},"2":{"objectClass":"MindNode","ID":"BK02S","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"51353","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"538WB","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"7G5RY","lineColorHex":"#26BBFF","text":"所有超时执行的代码（函数）都会在全局作用域中的一个匿名函数中运行，因此函数中的this值在非严格模式下始终指向window，而在严格模式下是undefined。如果给setTimeout()提供了一个箭头函数，那么this会保留为定义它时所在的词汇作用域。"},"objectClass":"NSArray"},"text":"setTimeout()的第二个参数只是告诉JavaScript引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完才能执行。"},"objectClass":"NSArray"},"text":"1. setTimeout\n接受两个参数要执行的代码和在执行回调函数前等待的时间（毫秒）。调用setTimeout()时，会返回一个表示该超时排期的数值ID。可以通过接收这个ID取消这个任务，clearTimeout（ID）","maxWidthLine":306},"1":{"objectClass":"MindNode","ID":"BV81C","lineColorHex":"#26BBFF","text":"2. setInterval\n同上差不多，只是每隔指定的时间就会执行一次。"},"objectClass":"NSArray"},"text":"5、定时器\nsetTimeout（）用于指定在一段时间后执行某些代码，setInterval（）用于指定每隔一段时间执行某些代码。"},"3":{"objectClass":"MindNode","ID":"O8PJF","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"P3U81","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"79I9O","lineColorHex":"#26BBFF","text":"confirm\n确认框有两个按钮：“Cancel”（取消）和“OK”（确定）。要知道用户单击了OK按钮还是Cancel按钮，可以判断confirm()方法的返回值：true表示单击了OK按钮，false表示单击了Cancel按钮或者通过单击某一角上的X图标关闭了确认框。"},"1":{"objectClass":"MindNode","ID":"FJZ77","lineColorHex":"#26BBFF","text":"最后一种对话框是提示框，通过调用prompt()方法来显示。提示框的用途是提示用户输入消息。除了OK和Cancel按钮，提示框还会显示一个文本框，让用户输入内容。"},"objectClass":"NSArray"},"text":"使用alert()、confirm()和prompt()方法，可以让浏览器调用系统对话框向用户显示消息。\n这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。"},"objectClass":"NSArray"},"text":"6、 系统对话框"},"objectClass":"NSArray"},"text":"5. 导航与打开新窗口"},"objectClass":"NSArray"},"text":"1.window对象\n表示浏览器的实例，表示ES的Global对象，另一个就是浏览器窗口的JS接口。"},"1":{"objectClass":"MindNode","ID":"93758","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"F2FE6","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"XX554","lineColorHex":"#26BBFF","text":"\n\n\nhttp://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents\n假设当前加载的是这个URL路径。","markType":7},"objectClass":"NSArray"},"text":"location是最有用的BOM对象之一，提供了当前窗口中加载文档的信息，它既是window的属性，也是document的属性。也就是说，window.location和document.location指向同一个对象。保存着把URL解析为离散片段后能够通过属性访问的信息。"},"1":{"objectClass":"MindNode","ID":"1FYHU","lineColorHex":"#26BBFF","text":"1、 查询字符串\n现在，查询字符串中的每个参数都是返回对象的一个属性，这样使用起来就方便了。使用URLSearchParams 构造函数将查询字符串传入即可。"},"2":{"objectClass":"MindNode","ID":"270K2","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"EGIQ8","lineColorHex":"#26BBFF","text":"如果不希望增加历史记录，可以使用replace()方法。这个方法接收一个URL参数，但重新加载后不会增加历史记录。调用replace()之后，用户不能回到前一页。"},"1":{"objectClass":"MindNode","ID":"OWY4K","lineColorHex":"#26BBFF","text":"最后一个修改地址的方法是reload()，它能重新加载当前显示的页面。调用reload()而不传参数，页面会以最有效的方式重新加载。"},"2":{"objectClass":"MindNode","ID":"RZO7Q","lineColorHex":"#26BBFF","text":"location.assign()\n这行代码会立即启动导航到新URL的操作，同时在浏览器历史记录中增加一条记录。如果给location.href或window.location设置一个URL，也会以同一个URL值调用assign()方法。"},"3":{"objectClass":"MindNode","ID":"P00BY","lineColorHex":"#26BBFF","text":"除了hash之外，只要修改location的一个属性，就会导致页面重新加载新URL。也就是hash、search、hostname、pathname和port属性被设置为新值之后都会修改当前URL。"},"objectClass":"NSArray"},"text":"2. 操作地址\n可是使用location.assign()、window.location（）、location.href()三个方法操作。在这3种修改浏览器地址的方法中，设置location.assign是最常见的。修改location对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname和port属性被设置为新值之后都会修改当前URL。"},"3":{"objectClass":"MindNode","ID":"0GZ8V","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"36XX0","lineColorHex":"#26BBFF","text":"P26.1.3"},"objectClass":"NSArray"},"text":"3. 读取和写入cookie"},"objectClass":"NSArray"},"text":"location对象"},"2":{"objectClass":"MindNode","ID":"5J4D2","lineColorHex":"#26BBFF","text":"3. navigator对象\n只要浏览器启用JavaScript, navigator对象就一定存在。navigator对象的属性通常用于确定浏览器的类型。"},"3":{"objectClass":"MindNode","ID":"O1YV3","lineColorHex":"#26BBFF","text":"4. screen对象\nwindow的另一个属性screen对象，是为数不多的几个在编程中很少用的JavaScript对象。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度。"},"4":{"objectClass":"MindNode","ID":"Q4DQQ","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"211K0","lineColorHex":"#26BBFF","text":"1. 导航\ngo()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值是后退，正值是前进。\n有两个间简写方法：back（）和forward（）。\n\nlength属性则暴露历史记录有多少个条目。"},"objectClass":"NSArray"},"text":"5. history对象\nhistory对象表示当前窗口首次使用以来用户的导航历史记录。因为history是window的属性，所以每个window都有自己的history对象。出于安全不会暴露URL，但是可以没有URL的情况下前进或者后退。"},"objectClass":"NSArray"},"text":"BOM"},"9":{"objectClass":"MindNode","ID":"TJM9G","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"E2847","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"J7744","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"8SS30","lineColorHex":"#37C45A","text":"1. nodeName和nodeValue\n保存着节点的信息。nodeName就是元素标签名。如果把这个节点付给一个变量，则Value始终为null。"},"1":{"objectClass":"MindNode","ID":"I1586","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"0CT9I","lineColorHex":"#37C45A","text":"父节点和它的第一个及最后一个节点有专门的属性：firstChild和lastChild指向childNodes中的第一个和最后一个子元素。hasChildNodes()方法如果返回true则表示节点有一个或多个子节点。"},"1":{"objectClass":"MindNode","ID":"6G205","lineColorHex":"#37C45A","text":"最后还有一个所有节点都共享的关系。ownerDocument属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中"},"2":{"objectClass":"MindNode","ID":"FZI5H","lineColorHex":"#37C45A","text":"previousSibling方法nextSibling和可以在childNodes列表中进行导航。"},"objectClass":"NSArray"},"text":"2. 节点关系\n每个节点都有一个childNodes属性，其中包含一个NodeList的实例。NodeList对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在NodeList中反映出来。\n每个节点也有一个parentNode属性，指向其DOM树中的父元素。"},"2":{"objectClass":"MindNode","ID":"55474","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"W65G4","lineColorHex":"#37C45A","text":"如果想把节点放到childNodes中的特定位置而不是末尾，则可以使用insertBefore()方法。这个方法接收两个参数：要插入的节点和参照节点。这两个方法不会删除任何已有节点，"},"1":{"objectClass":"MindNode","ID":"HMDK7","lineColorHex":"#37C45A","text":"replaceChild()方法接收两个参数：要插入的节点和要替换的节点。"},"2":{"objectClass":"MindNode","ID":"K8YCV","lineColorHex":"#37C45A","text":"要移除节点而不是替换节点，可以使用removeChild()方法。这个方法接收一个参数，即要移除的节点。"},"objectClass":"NSArray"},"text":"3. 操纵节点\nappendChild（）方法，用于在childNodes列表末尾添加节点，返回新添加的节点。\n如果把文档中已经存在的节点传给appendChild()，则这个节点会从之前的位置被转移到新位置。"},"3":{"objectClass":"MindNode","ID":"7QP4L","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"WWI5X","lineColorHex":"#37C45A","text":"第一个是cloneNode()，会返回与调用它的节点一模一样的节点。cloneNode()方法接收一个布尔值参数，表示是否深复制。在传入true参数时，会进行深复制，即复制节点及其整个子DOM树。如果传入false，则只会复制调用该方法的节点。"},"1":{"objectClass":"MindNode","ID":"7H83S","lineColorHex":"#37C45A","text":"normalize（）方法，在节点上调用normalize()方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。"},"objectClass":"NSArray"},"text":"4. 其他方法"},"objectClass":"NSArray"},"text":"1、Node类型\n在JS中，所有节点类型都继承Node类型，所有类型都共享相同的基本属性和方法。每个节点都有nodeType属性，表示该节点的类型。最常用到的节点是元素节点和文本节点。节点类型由定义在Node类型上的12个数值常量表示。","maxWidthLine":307},"1":{"objectClass":"MindNode","ID":"1V5GK","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"PS4O8","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"UK2PT","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"6I44T","lineColorHex":"#37C45A","text":"所有浏览器都支持document.documentElement和document.body属性，获取html元素和body元素。"},"1":{"objectClass":"MindNode","ID":"2F3N6","lineColorHex":"#37C45A","text":"Document类型另一种可能的子节点是DocumentType。<!doctype>标签是文档中独立的部分，其信息可以通过doctype属性（在浏览器中是document.doctype）来访问"},"objectClass":"NSArray"},"text":"Document类型另一种可能的子节点是DocumentType。<! doctype>标签是文档中独立的部分，其信息可以通过doctype属性（在浏览器中是document.doctype）来访问。","remark":"appendChild()、removeChild()和replaceChild()方法不会用在document对象上","remarkDisplay":true},"objectClass":"NSArray"},"text":"1. 文档子节点\nDocument节点的子节点可以是，DocumentType、Element、Processing-Instruction或Comment。提供了两个访问子节点的属性，document.documentElement，始终指向html元素，document.body指向body元素。"},"1":{"objectClass":"MindNode","ID":"YQQ5V","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"31G5I","lineColorHex":"#37C45A","text":"1. document.title属性\n包含<title>元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。"},"1":{"objectClass":"MindNode","ID":"UL7JT","lineColorHex":"#37C45A","text":"2. 三个属性\n3个属性是URL、domain和referrer。其中，URL包含当前页面的完整URL（地址栏中的URL）, domain包含页面的域名，而referrer包含链接到当前页面的那个页面的URL。在这些属性中，只有domain属性是可以设置的。"},"objectClass":"NSArray"},"text":"2.文档信息"},"2":{"objectClass":"MindNode","ID":"VS379","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"T2IB8","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"V38X1","lineColorHex":"#37C45A","text":"1. getElementById()方法接收一个参数，即要获取元素的ID，如果找到了则返回这个元素，如果没找到则返回null。参数ID必须跟元素在页面中的id属性值完全匹配，包括大小写。"},"1":{"objectClass":"MindNode","ID":"OF1S3","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"N7778","lineColorHex":"#37C45A","text":"要取得文档中的所有元素，可以给getElementsByTagName()传入＊"},"objectClass":"NSArray"},"text":"2. getElementsByTagName()是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的NodeList。"},"2":{"objectClass":"MindNode","ID":"XX2T7","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"6C976","lineColorHex":"#37C45A","text":"使用document 属性获取对象\ndocument.元素名，就会返回代表一个或多个元素的对象。这就是使用HTMLCollection来实现的。"},"objectClass":"NSArray"},"text":"3. HTMLCollection对象还有一个额外的方法namedItem()，可通过标签的name属性取得某一项的引用。"},"objectClass":"NSArray"},"text":"getElementById()和getElementsByTagName()就是Document类型提供的两个方法。"},"1":{"objectClass":"MindNode","ID":"4Y73Y","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"EZUI1","lineColorHex":"#37C45A","text":"getElementsByName()方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的name属性才能确保把正确的值发送给服务器"},"objectClass":"NSArray"},"text":"HTMLDocument类型上定义的获取元素的第三个方法是getElementsByName()。顾名思义，这个方法会返回具有给定name属性的所有元素。"},"2":{"objectClass":"MindNode","ID":"9O3ED","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"6E4X7","lineColorHex":"#37C45A","text":"getElementByClassName，该方法返回的是一个HTMLCollection集合并不是单个元素对象。"},"objectClass":"NSArray"},"text":"getElementByClassName（<class>）\n返回带有指定class值得元素。\nquerySelector（<selector>）返回匹配指定CSS选择器的第一个元素。\nquerySelectorAll（<selector>）返回匹配指定css选择器得所有元素。"},"objectClass":"NSArray"},"text":"3. 定位元素"},"3":{"objectClass":"MindNode","ID":"S60Y7","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"81G25","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"MAF3G","lineColorHex":"#37C45A","text":"document.anchors包含文档中所有带name属性的<a>元素。\ndocument.forms包含文档中所有<form>元素（与document.getElementsByTagName (\"form\")返回的结果相同）。\ndocument.images包含文档中所有<img>元素（与document.getElementsByTagName (\"img\")返回的结果相同）。\ndocument.links包含文档中所有带href属性的<a>元素。"},"objectClass":"NSArray"},"text":"特殊集合是访问文档中公共部分的快捷方式"},"objectClass":"NSArray"},"text":"4. 特殊集合"},"4":{"objectClass":"MindNode","ID":"715Q8","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"LK20B","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"187WO","lineColorHex":"#37C45A","text":"无论检测什么都返回true，已经废弃了。"},"objectClass":"NSArray"},"text":"由于DOM有多个Level和多个部分，因此确定浏览器实现了DOM的哪些部分是很必要的。\ndocument.implementation属性是一个对象，其中提供了与浏览器DOM实现相关的信息和能力。只定义了一个方法，即hasFeature()。这个方法接收两个参数：特性名称和DOM版本。"},"objectClass":"NSArray"},"text":"5. DOM兼容性检测"},"5":{"objectClass":"MindNode","ID":"VGE87","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"4I4VF","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"2W2WU","lineColorHex":"#37C45A","text":"1. \nwrite()和writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中。write()简单地写入文本，而writeln()还会在字符串末尾追加一个换行符（\\n）。"},"objectClass":"NSArray"},"text":"对应四个方法write()、writeln()、open()和close()。"},"objectClass":"NSArray"},"text":"6. 文档写入"},"objectClass":"NSArray"},"text":"2. Document类型\n文档对象document是HTMLDocument的实例（HTMLDocument继承Document），表示整个HTML页面。"},"2":{"objectClass":"MindNode","ID":"L7081","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"MC785","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"3EP82","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"AK4K8","lineColorHex":"#37C45A","text":"所有HTML元素都通过HTMLElement类型表示，包括其直接实例和间接实例。从element类型继承了标准属性，id、title、lang、dir（文本方向、classname（类名）"},"objectClass":"NSArray"},"text":"1. 可以通过nodeName或tagName属性来获取已经定位到的元素的标签名。它们返回值是一样的。最好将标签名转为小写，再进行判断等操作。！！！","maxWidthLine":307},"1":{"objectClass":"MindNode","ID":"6F631","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"333JB","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"8I3LP","lineColorHex":"#37C45A","text":"通过DOM对象访问style属性和类，与getAttribute（）方法返回的值不一样，DOM对象获取style和类返回的分别是CSSStyleDe对象和JS函数，get方法则返回的是CSS字符串和字符串形式源码。"},"objectClass":"NSArray"},"text":"注意传给getAttribute()的属性名与它们实际的属性名是一样的，而不是属性值。也可以取到自定义属性。","remark":"考虑到以上差异，开发者在进行DOM编程时通常会放弃使用getAttribute()而只使用对象属性。getAttribute()主要用于取得自定义属性的值。","summaries":{"0":{"objectClass":"NodeSummary","ID":"3M14S","text":"设置属性和获取属性，分为两种情况，一种是通过这两个方法来进行，还可以直接在获取的元素对象上直接获取和设置。","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"},"remarkDisplay":true},"1":{"objectClass":"MindNode","ID":"3M14S","lineColorHex":"#37C45A","text":"setAttribute()，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则setAttribute()会以指定的值替换原来的值；"},"2":{"objectClass":"MindNode","ID":"XZIB6","lineColorHex":"#37C45A","text":"最后一个方法removeAttribute()用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉"},"3":{"objectClass":"MindNode","ID":"5XSWK","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"H7KSK","lineColorHex":"#37C45A","text":"getNamedItem（name），返回nodeName属性等于name的属性节点；removeNamedItem（name），删除nodeName属性等于name的节点；setNamedItem（node），向列表中添加node节点，以其nodeName为索引。item（pos），返回索引位置pos处的节点。"},"objectClass":"NSArray"},"text":"\n4. \nElement类型是唯一使用attributes属性的DOM节点类型。attributes属性其实包括了HTML元素所有属性的一个集合，以键值对的形式存储在attributes中，保存在NamedNodeMap对象中。"},"4":{"objectClass":"MindNode","ID":"65J5M","lineColorHex":"#37C45A","text":"6. 创建元素\n"},"objectClass":"NSArray"},"text":"2. 取得属性、设置属性\n与属性相关的DOM方法主要有3个：getAttribute()、setAttribute()和removeAttribute()。\n元素的属性就是DOM对象的属性，所以通过方法或者属性都是可以改变元素属性的值的。"},"objectClass":"NSArray"},"text":"Element表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。"},"objectClass":"NSArray"},"text":"Element类型"},"objectClass":"NSArray"},"text":"1.节点层级\ndocument节点表示每个文档的根节点，根节点的唯一子节点是<html>元素，文档元素。元素节点表示HTML元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。（Dom结构）"},"1":{"objectClass":"MindNode","ID":"6OF4L","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"7QIM7","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"C8C6G","lineColorHex":"#37C45A","text":"通过createElement（）创建script元素动态引入外部脚本，插入到文档树之前是不会下载脚本的。"},"1":{"objectClass":"MindNode","ID":"PK768","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"STW86","lineColorHex":"#37C45A","text":"1. 使用appendChild（document.createTextNode(脚本内容)） IE会报错，因为IE不支持常规DOM访问script的子节点，不过可以使用script.text属性来进行赋值，但是safari3.0之前不支持text属性，所以要定义一个变量存储。"},"1":{"objectClass":"MindNode","ID":"ROX72","lineColorHex":"#37C45A","text":"通过innerHTML属性创建的<script>元素永远不会执行。"},"objectClass":"NSArray"},"text":"通过创建文本节点动态插入JS源码，但是会有浏览器兼容问题。"},"objectClass":"NSArray"},"text":"1.动态脚本\n动态脚本就是在页面初始加载时不存在，之后又通过DOM包含的脚本。"},"1":{"objectClass":"MindNode","ID":"GF1M5","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"KS14S","lineColorHex":"#37C45A","text":"通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的JavaScript代码并没有先后顺序。"},"1":{"objectClass":"MindNode","ID":"QQ474","lineColorHex":"#37C45A","text":"通过创建文本节点写内联样式的时候，其他浏览器都支持但是IE会报与script相同的错误，解决方案是访问元素的styleSheet属性，这个属性又有一个cssText属性，然后给这个属性添加CSS代码。"},"objectClass":"NSArray"},"text":"2. 动态样式"},"2":{"objectClass":"MindNode","ID":"8R118","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"6KT61","lineColorHex":"#37C45A","text":"这3个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来"},"objectClass":"NSArray"},"text":"3. 使用NodeList\n实际上，NodeList就是基于DOM文档的实时查询。NamedNodeMap（元素属性图，HTMLCollection（元素定位获取的集合"},"objectClass":"NSArray"},"text":"2.DOM编程"},"2":{"objectClass":"MindNode","ID":"C52E5","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"A50E0","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"EG652","lineColorHex":"#37C45A","text":"MutationObserver的实例要通过调用MutationObserver构造函数并传入一个回调函数来创建"},"1":{"objectClass":"MindNode","ID":"53D14","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"HBOPQ","lineColorHex":"#37C45A","text":"关联之后的DOM对象，发生任何改变都会触发注册的回调函数，后代元素修改不会触发回调函数。"},"objectClass":"NSArray"},"text":"1. observe()方法\n新创建的MutationObserver实例不会关联任何DOM，需要使用observer方法，第一个参数是要观察变化的DOM节点，第二参数是MutationObserverInit对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。"},"2":{"objectClass":"MindNode","ID":"78VI2","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"2352U","lineColorHex":"#37C45A","text":"传给回调函数的第二个参数是观察变化的MutationObserver的实例"},"objectClass":"NSArray"},"text":"2. 回调与MutationRecord\n创建MutationObserver时，传的回调函数会收到一个MutationRecord实例的数组。"},"3":{"objectClass":"MindNode","ID":"3WW79","lineColorHex":"#37C45A","text":"3. 复用mutationObserver\n多次调用observe()方法，可以复用一个MutationObserver对象观察多个不同的目标节点。此时，MutationRecord的target属性可以标识发生变化事件的目标节点。"},"objectClass":"NSArray"},"text":"1. 基本用法"},"objectClass":"NSArray"},"text":"3. MutationObserver接口","markType":5},"objectClass":"NSArray"},"text":"DOM\n文档对象模型（DOM, Document ObjectModel）是HTML和XML文档的编程接口。"},"10":{"objectClass":"MindNode","ID":"F5I8C","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"G175D","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"50A7X","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"91264","lineColorHex":"#1BD6E7","text":"在Document上使用querySelector()方法时，会从文档元素开始搜索；在Element上使用querySelector()方法时，则只会从当前元素的后代中查询。"},"objectClass":"NSArray"},"text":"1. query Selector（）\nquerySelector()方法接收CSS选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回null"},"1":{"objectClass":"MindNode","ID":"O18Y8","lineColorHex":"#1BD6E7","text":"2. querySelectorAll（）\nquerySelectorAll()方法跟querySelector()一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个NodeList的静态实例。"},"2":{"objectClass":"MindNode","ID":"14422","lineColorHex":"#1BD6E7","text":"3. match（）\nmatches()方法（在规范草案中称为matchesSelector()）接收一个CSS选择符参数，如果元素匹配则该选择符返回true，否则返回false。"},"objectClass":"NSArray"},"text":"Selectors API\nSelectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。在兼容浏览器中，Document类型和Element类型的实例上都会暴露这两个方法。"},"1":{"objectClass":"MindNode","ID":"H2UX5","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"8DHYE","lineColorHex":"#1BD6E7","text":"childElementCount，返回子元素数量（不包含文本节点和注释）；\nfirstElementChild，指向第一个Element类型的子元素（Element版firstChild）；lastElementChild，指向最后一个Element类型的子元素（Element版lastChild）；previousElementSibling，指向前一个Element类型的同胞元素（Element版previousSibling）；nextElementSibling，指向后一个Element类型的同胞元素（Element版nextSibling）。"},"objectClass":"NSArray"},"text":"元素遍历\nIE9之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了childNodes和firstChild等属性上的差异。","maxWidthLine":306},"2":{"objectClass":"MindNode","ID":"31Q91","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"E4DE8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"ITC70","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"YOB1E","lineColorHex":"#1BD6E7","text":"通过类名定位元素"},"objectClass":"NSArray"},"text":"1. getElementsByClassName()\n该方法暴露在document对象和所有element元素上，接受一个参数包含一个或多个类名字符串，返回类名中相应类的元素的nodeList。（现在返回的是HTMLCollection"},"1":{"objectClass":"MindNode","ID":"QZF6D","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"2VT3E","lineColorHex":"#1BD6E7","text":"classList是一个新的集合类型DOMTokenList的实例。也可以通过item（）或者中括号取得个别元素。"},"1":{"objectClass":"MindNode","ID":"NU9E5","lineColorHex":"#1BD6E7","text":"新增方法：add（）、contains（）、remove（）、toggle（）"},"objectClass":"NSArray"},"text":"2. classlist属性\n要操作类名，可以通过className属性实现添加、删除和替换。但className是一个字符串，所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。","maxWidthLine":307},"objectClass":"NSArray"},"text":"1. CSS类扩展\n为了适应开发者和他们对class属性的认可，HTML5增加了一些特性以方便使用CSS类。"},"1":{"objectClass":"MindNode","ID":"H111R","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"7C8XP","lineColorHex":"#1BD6E7","text":"首先是document.activeElement，始终包含当前拥有焦点的DOM元素。"},"1":{"objectClass":"MindNode","ID":"T925F","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"T241S","lineColorHex":"#1BD6E7","text":"这个方法就可以用来判断用户是否在操作页面。"},"objectClass":"NSArray"},"text":"其次是document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点。"},"objectClass":"NSArray"},"text":"2. 焦点管理"},"2":{"objectClass":"MindNode","ID":"V3ISK","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"D14LV","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"YM57I","lineColorHex":"#1BD6E7","text":"实际开发中，最好是把document.readState当成一个指示器，以判断文档是否加载完毕。"},"objectClass":"NSArray"},"text":"1. document.readystate\n有两个可能的值 loading，表示文档正在加载； complete，表示文档加载完成。"},"1":{"objectClass":"MindNode","ID":"818UL","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"PPLBR","lineColorHex":"#1BD6E7","text":"这个属性唯一的任务是指示浏览器当前处于什么渲染模式。标准模式下document.compatMode的值是\"CSS1Compat\"，而在混杂模式下，document.compatMode的值是\"BackCompat\""},"objectClass":"NSArray"},"text":"2. compatMode"},"2":{"objectClass":"MindNode","ID":"OQOG7","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"1RB1N","lineColorHex":"#1BD6E7","text":"characterSet属性表示文档实际使用的字符集，也可以用来指定新字符集。"},"objectClass":"NSArray"},"text":"3. 字符集属性"},"objectClass":"NSArray"},"text":"3. HTMLDocument扩展"},"3":{"objectClass":"MindNode","ID":"8V444","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"WV5YL","lineColorHex":"#1BD6E7","text":"使用自定义属性需要使用data-前缀"},"1":{"objectClass":"MindNode","ID":"A3604","lineColorHex":"#1BD6E7","text":"定义了自定义数据属性后，可以通过元素的dataset属性来访问。dataset属性是一个DOMStringMap的实例，包含一组键/值对映射。"},"objectClass":"NSArray"},"text":"4. 自定义数据属性"},"4":{"objectClass":"MindNode","ID":"72458","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"HDC51","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"MU6J4","lineColorHex":"#1BD6E7","text":"在读取innerHTML属性时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。而在写入innerHTML时，则会根据提供的字符串值以新的DOM子树替代元素中原来包含的所有节点。"},"1":{"objectClass":"MindNode","ID":"ZX607","lineColorHex":"#1BD6E7","text":"写入模式：赋给innerHTML属性的值会被解析为DOM子树，并替代元素之前的所有节点。如果赋值中不包含任何HTML标签，则直接生成一个文本节点。"},"objectClass":"NSArray"},"text":"1. innerHTML属性"},"1":{"objectClass":"MindNode","ID":"C1PZE","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"73OF7","lineColorHex":"#1BD6E7","text":"在所有现代浏览器中，通过innerHTML插入的<script>标签是不会执行的。而在IE8及之前的版本中，只要这样插入的<script>元素指定了defer属性，且<script>之前是“受控元素”"},"objectClass":"NSArray"},"text":"2. 旧IE中的innerHTML"},"2":{"objectClass":"MindNode","ID":"F86L0","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"JVK16","lineColorHex":"#1BD6E7","text":"读取outerHTML属性时，会返回调用它的元素（及所有后代元素）的HTML字符串。"},"1":{"objectClass":"MindNode","ID":"3LQ42","lineColorHex":"#1BD6E7","text":"使用outerHTML设置的时候，就会取代根元素。"},"objectClass":"NSArray"},"text":"3. outerHTML属性"},"3":{"objectClass":"MindNode","ID":"75766","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"XK82P","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"752ZA","lineColorHex":"#1BD6E7","text":"\"beforebegin\"，插入当前元素前面，作为前一个同胞节点；\n\"afterbegin\"，插入当前元素内部，作为新的子节点或放在第一个子节点前面；\n\"beforeend\"，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；\n\"afterend\"，插入当前元素后面，作为下一个同胞节点。"},"objectClass":"NSArray"},"text":"两个方法都接受两个参数，第一个参数必须接受固定的四个取值为："},"objectClass":"NSArray"},"text":"4.insertAdjacentHTML（）以及\ninsert AdjacentText（）"},"objectClass":"NSArray"},"text":"5. 插入标记"},"5":{"objectClass":"MindNode","ID":"M905I","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"366LU","lineColorHex":"#1BD6E7","text":"比如，如果被移除的子树元素中之前有关联的事件处理程序或其他JavaScript对象（作为元素的属性），那它们之间的绑定关系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。"},"1":{"objectClass":"MindNode","ID":"63731","lineColorHex":"#1BD6E7","text":"在使用innerHTML、outerHTML和insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和JavaScript对象。"},"objectClass":"NSArray"},"text":"内存和性能问题"},"6":{"objectClass":"MindNode","ID":"5263L","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"78BDE","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"352SJ","lineColorHex":"#1BD6E7","text":"alignToTop是一个布尔值。\n■ true：窗口滚动后元素的顶部与视口顶部对齐。\n■ false：窗口滚动后元素的底部与视口底部对齐。"},"1":{"objectClass":"MindNode","ID":"41412","lineColorHex":"#1BD6E7","text":" scrollIntoViewOptions是一个选项对象。\n■ behavior：定义过渡动画，可取的值为\"smooth\"和\"auto\"，默认为\"auto\"。\n■ block：定义垂直方向的对齐，可取的值为\"start\"、\"center\"、\"end\"和\"nearest\"，默认为\"start\"。\n■ inline：定义水平方向的对齐，可取的值为\"start\"、\"center\"、\"end\"和\"nearest\"，默认为\"nearest\"。"},"objectClass":"NSArray"},"text":"有两个参数："},"objectClass":"NSArray"},"text":"scrollIntoView（）"},"objectClass":"NSArray"},"text":"HTML5"},"3":{"objectClass":"MindNode","ID":"ZC6JS","lineColorHex":"#1BD6E7","text":"专有扩展"},"objectClass":"NSArray"},"text":"DOM扩展","remark":"与HTML5一书重复，以H5为准。","remarkDisplay":true},"11":{"objectClass":"MindNode","ID":"S35UU","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"H1275","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"J58Z4","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"5MG8K","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"Y9GUJ","lineColorHex":"#1BD6E7","text":"在标准模式下，所有尺寸都必须包含单位。在混杂模式下，可以把style.width设置为\"20\"不加px单位。"},"1":{"objectClass":"MindNode","ID":"A50QG","lineColorHex":"#1BD6E7","text":"因为float是JavaScript的保留字，所以不能用作属性名。DOM2 Style规定它在style对象中对应的属性应该是cssFloat。"},"objectClass":"NSArray"},"text":"1. 因为CSS属性名使用连字符表示法（用连字符分隔两个单词，如background-image），所以在JavaScript中这些属性必须转换为驼峰大小写形式（如backgroundImage）"},"1":{"objectClass":"MindNode","ID":"87834","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"23U15","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"V6576","lineColorHex":"#1BD6E7","text":"在写模式下，给cssText赋值会重写整个style属性的值，意味着之前通过style属性设置的属性都会丢失。是一次性修改多个样式的快捷方式。"},"objectClass":"NSArray"},"text":"cssText，包含style属性中的CSS代码。\nlength，应用给元素的CSS属性数量。\nparentRule，表示CSS信息的CSSRule对象（下一节会讨论CSSRule类型）"},"1":{"objectClass":"MindNode","ID":"Y682I","lineColorHex":"#1BD6E7","text":"getPropertyPriority（propertyName），如果CSS属性propertyName使用了！important则返回\"important\"，否则返回空字符串。"},"2":{"objectClass":"MindNode","ID":"0GQ4E","lineColorHex":"#1BD6E7","text":"getPropertyValue（propertyName），返回属性propertyName的字符串值。注意要用css的样式名，不是JS中的。"},"3":{"objectClass":"MindNode","ID":"F1Q5W","lineColorHex":"#1BD6E7","text":"item（index），返回索引为index的CSS属性名。\nremoveProperty（propertyName），从样式中删除CSS属性propertyName。"},"4":{"objectClass":"MindNode","ID":"7R6C0","lineColorHex":"#1BD6E7","text":"setProperty（propertyName, value, priority），设置CSS属性propertyName的值为value, priority是\"important\"或空字符串。"},"5":{"objectClass":"MindNode","ID":"65063","lineColorHex":"#1BD6E7","text":"DOM2Style在document.defaultView上增加了getComputedStyle()方法。这个方法其实就是返回指定的元素所有的计算样式。"},"objectClass":"NSArray"},"text":"2. DOM样式属性和方法\nDOM2 Style规范也在style对象上定义了一些属性和方法。"},"objectClass":"NSArray"},"text":"1. 存取元素样式（style）\n任何支持style属性的HTML元素在JS中都会有一个style属性，包含style属性样式信息但是不包含外部样式和文档样式继承来的。"},"1":{"objectClass":"MindNode","ID":"4FJ55","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"GH1YY","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"1JB85","lineColorHex":"#1BD6E7","text":"通过<link>或<style>元素也可以直接获取CSSStyleSheet对象。DOM在这两个元素上暴露了sheet属性，其中包含对应的CSSStyleSheet对象。"},"objectClass":"NSArray"},"text":"document.styleSheets表示文档中可用的样式表集合。该方法返回StyleSheetList数组，里面是CSSStyleSheet类型的对象。这个对象有很多属性和方法，来获取<link>元素和<style>元素上的信息。"},"1":{"objectClass":"MindNode","ID":"YY44G","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"ZMDKR","lineColorHex":"#1BD6E7","text":"这些是有关CSSStyleRule的属性和方法","summaries":{"0":{"objectClass":"NodeSummary","ID":"1JB85","text":"css规则（相关对象","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"objectClass":"NSArray"},"text":"CSSStyleSheet类型的对象中，CssRules是CssRuleList类型的对象，包含CSSStyleRule对象。最常用的是表示样式信息的CSSStyleRule。"},"2":{"objectClass":"MindNode","ID":"2L5Y8","lineColorHex":"#1BD6E7","text":"2. 创建规则\n"},"objectClass":"NSArray"},"text":"2. 操作样式表\nCSSStyleSheet类型表示CSS样式表，包括使用<link>元素和通过<style>元素定义的样式表。"},"2":{"objectClass":"MindNode","ID":"DE34H","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"977V8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"43ML8","lineColorHex":"#1BD6E7","text":"offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度（如果可见）和上、下边框的高度。"},"1":{"objectClass":"MindNode","ID":"KF50R","lineColorHex":"#1BD6E7","text":"offsetWidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度（如果可见）和左、右边框的宽度。"},"2":{"objectClass":"MindNode","ID":"5P5SB","lineColorHex":"#1BD6E7","text":"offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数。","summaries":{"0":{"objectClass":"NodeSummary","ID":"15K7E","text":"这个便宜距离是相对于包含块计算的，并不是浏览器窗口。","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"3":{"objectClass":"MindNode","ID":"15K7E","lineColorHex":"#1BD6E7","text":" offsetTop，元素上边框外侧距离包含元素上边框内侧的像素数。"},"objectClass":"NSArray"},"text":"1. 偏移尺寸"},"1":{"objectClass":"MindNode","ID":"0TWOJ","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"46066","lineColorHex":"#1BD6E7","text":"元素的客户端尺寸（client dimensions）包含元素内容及其内边距所占用的空间。"},"1":{"objectClass":"MindNode","ID":"3O447","lineColorHex":"#1BD6E7","text":"clientWidth是内容区宽度加左、右内边距宽度，clientHeight是内容区高度加上、下内边距高度。"},"objectClass":"NSArray"},"text":"2. 客户端尺寸"},"objectClass":"NSArray"},"text":"3. 元素尺寸"},"objectClass":"NSArray"},"text":"1. 样式\nDOM2 Style为这3种应用样式的机制都提供了API。","maxWidthLine":306},"objectClass":"NSArray"},"text":"DOM2和DOM3"},"12":{"objectClass":"MindNode","ID":"652F3","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"6XDD6","lineColorHex":"#FFC700","text":"JavaScript与HTML的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。"},"1":{"objectClass":"MindNode","ID":"85FDF","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"D8JMR","lineColorHex":"#FFC700","text":"1、事件冒泡\nIE事件流被称为事件冒泡，因为事件从最具体的元素开始触发，一直向上传播到document元素。沿DOM树，依次触发直到document对象。\n所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。"},"1":{"objectClass":"MindNode","ID":"YO8EK","lineColorHex":"#FFC700","text":"2. 事件捕获\n事件捕获指，最不具体的节点最先收到事件，最具体的节点最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。"},"2":{"objectClass":"MindNode","ID":"K44S7","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"2V7EO","lineColorHex":"#FFC700","text":"在DOM事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这是因为捕获阶段从document到<html>再到<body>就结束了。下一阶段，即会在<div>元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分（稍后讨论）。"},"objectClass":"NSArray"},"text":"3. DOM事件流\nDOM2 Ecents规定事件流分为三个阶段：事件捕获、到达目标、事件冒泡。"},"objectClass":"NSArray"},"text":"1. 事件流\n描述了页面接收事件的顺序。IE将支持事件冒泡流，而Netscape Communicator将支持事件捕获流。"},"2":{"objectClass":"MindNode","ID":"8Z8XB","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"58824","lineColorHex":"#FFC700","text":"为响应事件而调用的函数被称为事件处理程序，或者事件监听器。事件处理程序的名字以\"on\"开头。"},"1":{"objectClass":"MindNode","ID":"036F8","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"XXU27","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"GGA45","lineColorHex":"#FFC700","text":"所以不管事件处理程序的值是JS代码还是外部函数，都会被封装进这个函数中。"},"1":{"objectClass":"MindNode","ID":"H8M36","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"94TGI","lineColorHex":"#FFC700","text":"正是因为上面那个特点，假如给表单的input元素绑定了事件处理程序，则可以在函数中省略document.forms[0].elements.FirstName这一大段引用，直接使用FirstName就可以取得input元素的各种属性。","summaries":{"0":{"objectClass":"NodeSummary","ID":"76DJ9","text":"HTML处理程序这种方法，事件处理程序函数的作用域是被扩展到document的，相当于注册在捕获阶段","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"objectClass":"NSArray"},"text":"这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中，document和元素自身的成员都可以被当成局部变量来访问。是通过with（）实现的。"},"objectClass":"NSArray"},"text":"以这种方式创建的事件处理程序（在元素内联实现）。会创建一个函数来封装属性的值（也就是事件处理程序的代码），这个函数有一个特殊的局部变量event。this值相当于事件的目标元素。"},"1":{"objectClass":"MindNode","ID":"76DJ9","lineColorHex":"#FFC700","text":"如果需要修改事件处理程序，则必须在两个地方，即HTML和JavaScript中，修改代码。很麻烦所以大多数人都是用Js指定数据处理程序。"},"objectClass":"NSArray"},"text":"1. HTML事件处理程序\n特定元素支持的每个事件都可以使用事件处理程序的名字以HTML属性的形式写在元素标签内，属性值为JS代码。作为事件处理程序执行的代码可以访问全局作用域中的一切。"},"2":{"objectClass":"MindNode","ID":"7193B","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"SU118","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"K3B66","lineColorHex":"#FFC700","text":"每个元素（包括window和document）都有通常小写的事件处理程序属性，比如onclick，将一个函数赋值给事件处理程序属性即可。","summaries":{"0":{"objectClass":"NodeSummary","ID":"2124I","text":"DOM0事件处理程序的作用域只在元素作用域内。","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"objectClass":"NSArray"},"text":"在JavaScript中指定事件处理程序的传统方式是把一个函数赋值给（DOM元素的）一个事件处理程序属性。\n也就是先获取元素对象，然后把一个函数也就是事件处理程序要执行的JS代码作为一个函数赋值给事件处理属性。"},"1":{"objectClass":"MindNode","ID":"NW858","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"2124I","lineColorHex":"#FFC700","text":"通过将事件处理程序属性的值设置为null，可以移除通过DOM0方式添加的事件处理程序。"},"objectClass":"NSArray"},"text":"像这样使用DOM0方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即this等于元素。以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。"},"objectClass":"NSArray"},"text":"2. DOM0事件处理程序"},"3":{"objectClass":"MindNode","ID":"11O1W","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"JZ6T3","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"NTMR6","lineColorHex":"#FFC700","text":"它们接收3个参数：事件名、事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。"},"1":{"objectClass":"MindNode","ID":"MY3M3","lineColorHex":"#FFC700","text":"与DOM0方式类似，这个事件处理程序同样在被附加到的元素的作用域中运行。使用DOM2方式的主要优势是可以为同一个事件添加多个事件处理程序。"},"2":{"objectClass":"MindNode","ID":"A2412","lineColorHex":"#FFC700","text":"通过addEventListener()添加的事件处理程序只能使用removeEventListener()并传入与添加时同样的参数来移除。传给removeEventListener()的事件处理函数必须与传给addEventListener()的是同一个。所以不能使用匿名函数做参数。"},"objectClass":"NSArray"},"text":"DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventListener()和removeEventListener()。"},"objectClass":"NSArray"},"text":"3. DOM2事件处理程序"},"4":{"objectClass":"MindNode","ID":"3I767","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"D55CL","lineColorHex":"#FFC700","text":"IE实现了与DOM类似的方法，即attachEvent()和detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。\n\n使用attachEvent()时，事件处理程序是在全局作用域中运行的，因此this等于window。\n\n也能添加多个事件，但是执行顺序和DOM\n方法不一样，后添加的先执行。"},"objectClass":"NSArray"},"text":"4. IE事件处理程序"},"5":{"objectClass":"MindNode","ID":"22PLP","lineColorHex":"#FFC700","text":"5.跨浏览器事件处理程序","markType":7},"objectClass":"NSArray"},"text":"2. 事件处理程序"},"3":{"objectClass":"MindNode","ID":"3J7I3","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"6G972","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"77017","lineColorHex":"#FFC700","text":"HTML、DOM0和DOM2添加处理程序，就算不显式的添加event参数，也会自动传event参数。"},"objectClass":"NSArray"},"text":"在DOM中发生事件时，事件处理函数会默认传一个参数event，它包含了比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。"},"1":{"objectClass":"MindNode","ID":"477S3","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"841UW","lineColorHex":"#FFC700","text":"所有事件对象都包含一些公共属性和方法。\ntarget、type、currentTarget。处理程序内部的this始终等于currentTarget，target则等于实际的目标元素。","remark":"事件处理程序的目标不等于事件处理程序绑定的那个元素（相对于父子元素来说）假如给父元素绑定事件，这种情况下点击按钮，this和currentTarget都等于document.body，这是因为它是注册事件处理程序的元素。而target属性等于按钮本身，这是因为那才是click事件真正的目标。"},"1":{"objectClass":"MindNode","ID":"1K168","lineColorHex":"#FFC700","text":"preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到href属性指定的URL。"},"2":{"objectClass":"MindNode","ID":"721F3","lineColorHex":"#FFC700","text":"stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续的事件捕获或冒泡。"},"3":{"objectClass":"MindNode","ID":"848V5","lineColorHex":"#FFC700","text":"eventPhase属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则eventPhase等于1；如果事件处理程序在目标上被调用，则eventPhase等于2；如果事件处理程序在冒泡阶段被调用，则eventPhase等于3。"},"objectClass":"NSArray"},"text":"1. DOM事件对象\nevent对象是浏览器传给事件处理程序的唯一参数。\n通过HTML属性指定的事件处理程序，也可以使用event引用事件。在事件处理程序内部，this对象始终等于currentTarget和target。"},"2":{"objectClass":"MindNode","ID":"L722Q","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"B8962","lineColorHex":"#FFC700","text":"如果以DOM0的方式指定，则event对象只是window的一个属性。\n如果事件处理程序是使用attachEvent()指定的（DOM2方式），则event对象会作为唯一的参数传给处理函数。虽然event任然是window对象的属性，但是会作为参数传入。"},"objectClass":"NSArray"},"text":"2. IE事件对象"},"objectClass":"NSArray"},"text":"3.事件对象"},"4":{"objectClass":"MindNode","ID":"F71E5","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"41Y1H","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"IF941","lineColorHex":"#FFC700","text":"1、load事件\n在window对象上，load事件会在整个页面（包括所有外部资源如图片、JavaScript文件和CSS文件）加载完成后触发。\n第一种使用方式，使用JSDOM2的形式。\n第二种向<body>元素添加onload属性。"},"objectClass":"NSArray"},"text":"1.用户界面事件"},"1":{"objectClass":"MindNode","ID":"1336U","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"797A8","lineColorHex":"#FFC700","text":"1、客户端坐标\n鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在event对象的clientX和clientY属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。"},"1":{"objectClass":"MindNode","ID":"H65CP","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"THMY5","lineColorHex":"#FFC700","text":"可以通过客户端坐标和滚动信息计算出来。滚动信息可以从document.body（混杂模式）或document.documentElement（标准模式）的scrollLeft和scrollTop属性获取。"},"objectClass":"NSArray"},"text":"2、页面坐标\n页面坐标是事件发生时鼠标光标在页面上的坐标，通过event对象的pageX和pageY可以获取。\n\n在页面没有滚动时，pageX和pageY与clientX和clientY的值相同。"},"2":{"objectClass":"MindNode","ID":"8PBAX","lineColorHex":"#FFC700","text":"3、 屏幕坐标\n鼠标事件不仅是在浏览器窗口中发生的，也是在整个屏幕上发生的。可以通过event对象的screenX和screenY属性获取鼠标光标在屏幕上的坐标"},"3":{"objectClass":"MindNode","ID":"HS9UP","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"18EI4","lineColorHex":"#FFC700","text":"这几属性会在各自对应的修饰键被按下时包含布尔值true，没有被按下时包含false。"},"objectClass":"NSArray"},"text":"4. 修饰键\n键盘上的修饰键Shift、Ctrl、Alt和Meta经常用于修改鼠标事件的行为。DOM规定了4个属性来表示这几个修饰键的状态：shiftKey、ctrlKey、altKey和metaKey。"},"4":{"objectClass":"MindNode","ID":"8FHTU","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"E3DUQ","lineColorHex":"#FFC700","text":"对mouseover和mouseout事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对mouseover事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。"},"objectClass":"NSArray"},"text":"5. 相关元素"},"5":{"objectClass":"MindNode","ID":"4E346","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"08W5J","lineColorHex":"#FFC700","text":"对mousedown和mouseup事件来说，event对象上会有一个button属性，表示按下或释放的是哪个按键。DOM为这个button属性定义了3个值：0表示鼠标主键、1表示鼠标中键（通常也是滚轮键）、2表示鼠标副键。"},"objectClass":"NSArray"},"text":"6.鼠标按键"},"6":{"objectClass":"MindNode","ID":"WH686","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"H91V7","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"95H1F","lineColorHex":"#FFC700","text":"当鼠标滚轮向前滚动时，wheelDelta每次都是+120；而当鼠标滚轮向后滚动时，wheelDelta每次都是-120（"},"objectClass":"NSArray"},"text":"这个事件会在任何元素上触发，并（在IE8中）冒泡到document和（在所有现代浏览器中）window。mousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为wheelDelta的新属性。"},"objectClass":"NSArray"},"text":"7.mousewheel事件"},"objectClass":"NSArray"},"text":"2. 鼠标事件"},"objectClass":"NSArray"},"text":"4. 事件类型"},"5":{"objectClass":"MindNode","ID":"FHD8G","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"6DZJ6","lineColorHex":"#FFC700","text":"在JavaScript中，页面中事件处理程序的数量与页面整体性能直接相关。"},"1":{"objectClass":"MindNode","ID":"22ZB8","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"2S6KR","lineColorHex":"#FFC700","text":"给不同的元素绑定点击事件，就会非常消耗内存并且有雷同代码。使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序，就可以解决问题。\n\n所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案。"},"objectClass":"NSArray"},"text":"1. 事件委托\n“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。"},"2":{"objectClass":"MindNode","ID":"E30S2","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"57Y7V","lineColorHex":"#FFC700","text":"把事件处理程序指定给元素后，在浏览器代码和负责页面交互的JavaScript代码之间就建立了联系。这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用的事件处理程序。很多Web应用性能不佳都是由于无用的事件处理程序长驻内存导致的。"},"objectClass":"NSArray"},"text":"2. 删除事件处理程序"},"objectClass":"NSArray"},"text":"内存与性能"},"6":{"objectClass":"MindNode","ID":"H23K0","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"8HV8R","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"KTM6R","lineColorHex":"#FFC700","text":"DOM2是复数，DOM3是单数。\n\"UIEvents\"（DOM3中是\"UIEvent\"）\n\"MouseEvents\"（DOM3中是\"MouseEvent\"）\n\"HTMLEvents\"（DOM3中没有）"},"1":{"objectClass":"MindNode","ID":"J4O25","lineColorHex":"#FFC700","text":"最后一步是触发事件。要使用dispatchEvent（）方法。dispatchEvent()方法接收一个参数，即表示要触发事件的event对象。"},"objectClass":"NSArray"},"text":"1. DOM事件模拟\n任何时候，都可以使用document.createEvent()方法创建一个event对象。方法接受一个参数，表示要创建事件类型的字符串。"},"objectClass":"NSArray"},"text":"模拟事件"},"objectClass":"NSArray"},"text":"事件"},"13":{"objectClass":"MindNode","ID":"BL3CT","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"C36G0","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"J78DQ","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2B7Q9","lineColorHex":"#DC306C","text":"在submit事件回调函数中，调用preventDefault()方法可以阻止表单提交。"},"1":{"objectClass":"MindNode","ID":"PPLE0","lineColorHex":"#DC306C","text":"以form.submit()提交表单不会触发submit事件，所以需要先做表单验证。"},"2":{"objectClass":"MindNode","ID":"P1D5I","lineColorHex":"#DC306C","text":"用户可能多次点击提交按钮，解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过onsubmit事件处理程序取消之后的表单提交。"},"objectClass":"NSArray"},"text":"提交按钮使用type属性为submit来定义的，以及type属性为image的input。以这种方式提交表单在向服务器发送请求之前会触发submit事件，就有一个验证表单的机会。"},"1":{"objectClass":"MindNode","ID":"3SJP4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5X198","lineColorHex":"#DC306C","text":"用户单击重置按钮重置表单会触发reset事件。这个事件为取消重置提供了机会。调用preventDefault（）取消默认事件。"},"objectClass":"NSArray"},"text":"2.重置表单\n重置按钮可以使用type属性为\"reset\"的<input>或<button>元素来创建"},"2":{"objectClass":"MindNode","ID":"OR3A2","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"LDD67","lineColorHex":"#DC306C","text":"表单字段的公共属性\nvalue是要提交给服务器的字段值。除了form属性以外，JavaScript可以动态修改任何属性。"},"1":{"objectClass":"MindNode","ID":"7KQYG","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"UO28G","lineColorHex":"#DC306C","text":"调用blur()时，焦点不会转移到任何特定元素，仅仅只是从调用这个方法的元素上移除了。"},"objectClass":"NSArray"},"text":"表单字段的公共方法\n每个表单字段都有两个公共方法：focus()和blur()。当字段type属性被设置为hidden时，再给字段使用focus（）会报错。"},"2":{"objectClass":"MindNode","ID":"Z7Q22","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5ZYM1","lineColorHex":"#DC306C","text":" blur：在字段失去焦点时触发。\nchange：在<input>和<textarea>元素的value发生变化且失去焦点时触发，或者在<select>元素中选中项发生变化时触发。 focus：在字段获得焦点时触发。"},"objectClass":"NSArray"},"text":"表单字段公共事件"},"objectClass":"NSArray"},"text":"3. 表单字段\n所有表单元素都是表单elements属性包含的一个值，每个字段都以它们出现在HTML标记中的次序保存，可以通过索引和name属性访问。"},"objectClass":"NSArray"},"text":"1. 表单基础"},"objectClass":"NSArray"},"text":"表单脚本"},"14":{"objectClass":"MindNode","ID":"LG13M","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"8A7BK","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"MQRJ7","lineColorHex":"#26BBFF","text":"requestAnimationFrame()方法接收一个参数，此参数是一个要在重绘屏幕前调用的函数。这个函数就是修改DOM样式以反映下一次重绘有什么变化的地方。"},"objectClass":"NSArray"},"text":"1. 使用requestAnimationFrame\n这个方法会告诉浏览器要执行动画了"},"1":{"objectClass":"MindNode","ID":"ZU4IO","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"M255R","lineColorHex":"#26BBFF","text":"填充和描边\n显示效果取决于两个属性：fillStyle和strokeStyle。字符串表示颜色值，可以是CSS支持的任意格式。"},"1":{"objectClass":"MindNode","ID":"62L86","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"41O60","lineColorHex":"#26BBFF","text":"描边宽度由lineWidth属性控制，它可以是任意整数值。类似地，lineCap属性控制线条端点的形状［\"butt\"（平头）、\"round\"（出圆头）或\"square\"（出方头）］，而lineJoin属性控制线条交点的形状［\"round\"（圆转）、\"bevel\"（取平）或\"miter\"（出尖）］。"},"objectClass":"NSArray"},"text":"绘制矩形\n绘制矩形相关的方法有3个：fillRect()、strokeRect()和clearRect()。这些方法都接收4个参数：矩形x坐标、矩形y坐标、矩形宽度和矩形高度。"},"2":{"objectClass":"MindNode","ID":"73G1J","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"9UCKA","lineColorHex":"#26BBFF","text":"有许多方法绘制路径，arc（）等等，查阅书籍"},"objectClass":"NSArray"},"text":"绘制路径\n要绘制路径，必须首先调用beginPath()方法以表示要开始绘制新路径。"},"3":{"objectClass":"MindNode","ID":"E7XP4","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"Z1J2B","lineColorHex":"#26BBFF","text":"这两个方法最终绘制的结果都取决于以下3个属性：font字体样式，textAlign文本的对其放肆，text'BaseLine指定文本的基线。"},"1":{"objectClass":"MindNode","ID":"V2WGH","lineColorHex":"#26BBFF","text":"由于绘制文本很复杂，特别是想把文本绘制到特定区域的时候，因此2D上下文提供了用于辅助确定文本大小的measureText()方法。"},"objectClass":"NSArray"},"text":"绘制文本\nfillText()和strokeText()。这两个方法都接收4个参数：要绘制的字符串、x坐标、y坐标和可选的最大像素宽度。","maxWidthLine":307},"4":{"objectClass":"MindNode","ID":"RF8D4","lineColorHex":"#26BBFF","text":"变换"},"objectClass":"NSArray"},"text":"2. 2D绘图上下文\n2D上下文的坐标原点(0, 0)在<canvas>元素的左上角。","maxWidthLine":306},"objectClass":"NSArray"},"text":"动画与Canvas图像"},"objectClass":"NSArray"},"children2":{"0":{"objectClass":"MindNode","ID":"14GY2","lineColorHex":"#37C45A","text":"javascript API","isLeft":true},"1":{"objectClass":"MindNode","ID":"223KQ","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1EWZY","lineColorHex":"#BF58F5","text":"","isLeft":true},"objectClass":"NSArray"},"text":"代理与反射","isLeft":true},"2":{"objectClass":"MindNode","ID":"3EK9L","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"66171","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"W3TU6","lineColorHex":"#26BBFF","text":"1.1 简单值\nJavaScript字符串与JSON字符串的主要区别是，JSON字符串必须使用双引号（单引号会导致语法错误）。","isLeft":true},"1":{"objectClass":"MindNode","ID":"52QR2","lineColorHex":"#26BBFF","text":"1.2 对象\nSON中的对象必须使用双引号把属性名包围起来。同一个对象中不允许出现两个相同的属性。","isLeft":true},"2":{"objectClass":"MindNode","ID":"4A3PR","lineColorHex":"#26BBFF","text":"1.3 数组\n可以与对象组合成顶级结构。","isLeft":true},"objectClass":"NSArray"},"text":"1. JSON语法\n支持三种类型的值：简单值，对象，数组。简单值除了undefined不能出现其他的都行。对象就是键值对形式与JS一样。","isLeft":true},"1":{"objectClass":"MindNode","ID":"KN4BS","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"25FB8","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"513LK","lineColorHex":"#26BBFF","text":"JSON对象有两个方法：stringify（）和parse（）。","isLeft":true},"1":{"objectClass":"MindNode","ID":"5187Q","lineColorHex":"#26BBFF","text":"默认情况下，JSON.stringify()会输出不包含空格或缩进的JSON字符串。序列化JS对象时，会忽略对象原型上的成员属性和方法，以及忽略值为undefined的属性。","isLeft":true},"2":{"objectClass":"MindNode","ID":"14BS7","lineColorHex":"#26BBFF","text":"JSON字符串可以直接传给JSON.parse()，然后得到相应的JavaScript值。","isLeft":true},"objectClass":"NSArray"},"text":"2.1 JSON对象\n因为JSON是JavaScript语法的子集，所以eval()可以解析、解释，并将其作为JavaScript对象和数组返回。ECMAScript 5增加了JSON全局对象，正式引入解析JSON的能力。","isLeft":true},"1":{"objectClass":"MindNode","ID":"BTIYN","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"UKHXV","lineColorHex":"#26BBFF","text":"1. 过滤结果\n如果第二参数是数组，stringify（）返回的结果只会包含该数组中列出的对象属性。\n如果第二参数是函数，该函数始终接收两个参数key和value，函数体是对JS对象的具体过滤操作。","isLeft":true},"1":{"objectClass":"MindNode","ID":"Y6266","lineColorHex":"#26BBFF","text":"2. 字符串缩进\n在这个参数是数值时，表示每一级缩进的空格数。如果缩进参数是一个字符串而非数值，那么JSON字符串中就会使用这个字符串而不是空格来缩进。","isLeft":true},"objectClass":"NSArray"},"text":"2.2 序列化选项\nstringify方法还有两个参数，第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果JSON字符串的选项。","isLeft":true},"objectClass":"NSArray"},"text":"2. 解析和序列化\nJSON可以直接被解析成可用的JavaScript对象。","isLeft":true,"maxWidthLine":306},"objectClass":"NSArray"},"text":"Json","isLeft":true},"3":{"objectClass":"MindNode","ID":"CRW54","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"980GJ","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"N8H9J","lineColorHex":"#37C45A","text":"1.1 finally子句\ntry或catch块无法阻止finally块执行，包括return语句。","isLeft":true},"1":{"objectClass":"MindNode","ID":"50714","lineColorHex":"#37C45A","text":"1.2 错误类型\nError是基类型，其他错误类型继承该类型。在try/catch语句的catch块中，可以使用instanceof操作符确定错误的类型。","isLeft":true},"2":{"objectClass":"MindNode","ID":"LP2L8","lineColorHex":"#37C45A","text":"1.3 try/catch的用法\n当try/catch中发生错误时，浏览器会认为错误被处理了。try/catch语句最好用在自己无法控制的错误上。","isLeft":true},"objectClass":"NSArray"},"text":"1. try/catch语句\n任何可能出错的代码都应该放到try块中，而处理错误的代码则放在catch块中。如果try块中有代码发生错误，代码会立即退出执行，并跳到catch语句中。与其他语言不同，即使在catch块中不使用错误对象，也必须为它定义名称。包含错误信息的message属性。","isLeft":true},"1":{"objectClass":"MindNode","ID":"R8WB9","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"4965U","lineColorHex":"#37C45A","text":"可以通过内置的错误类型来模拟浏览器错误。每种错误类型的构造函数都只接收一个参数，就是错误消息。new Error（）","isLeft":true},"1":{"objectClass":"MindNode","ID":"G3DAX","lineColorHex":"#37C45A","text":"1. 何时抛出错误\n实际编写JavaScript代码时，应该仔细评估每个函数，以及可能导致它们失败的情形。良好的错误处理协议可以保证只会发生你自己抛出的错误。","isLeft":true},"2":{"objectClass":"MindNode","ID":"46DU5","lineColorHex":"#37C45A","text":"2. 抛出错误与try/catch\n应该只在确切知道接下来该做什么的时候捕获错误。捕获错误的目的是阻止浏览器以其默认方式响应；抛出错误的目的是为错误提供有关其发生原因的说明。","isLeft":true},"objectClass":"NSArray"},"text":"2.抛出错误\n与try/catch语句对应的一个机制是throw操作符，用于在任何时候抛出自定义错误。throw操作符必须有一个值，但值的类型不限。使用throw操作符时，代码立即停止执行，除非try/catch语句捕获了抛出的值。","isLeft":true},"2":{"objectClass":"MindNode","ID":"65F78","lineColorHex":"#37C45A","text":"3. error事件\n任何没有被try/catch语句处理的错误都会在window对象上触发error事件。在onerror事件处理程序中，任何浏览器都不会传入event对象。相反，会传入3个参数：错误消息、发生错误的URL和行号。","isLeft":true},"3":{"objectClass":"MindNode","ID":"63UW3","lineColorHex":"#37C45A","text":"4. 错误处理策略\n作为开发者，应该非常清楚自己的代码在什么情况下会失败，以及失败会导致什么结果。另外，还要有一个系统跟踪这些问题。","isLeft":true},"4":{"objectClass":"MindNode","ID":"NSWCV","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"WY4FO","lineColorHex":"#37C45A","text":"1. 类型转换错误\n类型转换错误的主要原因是使用了会自动改变某个值的数据类型的操作符或语言构造。使用等于（==）或不等于（! =）操作符，以及在if、for或while等流控制语句中使用非布尔值，经常会导致类型转换错误。在流控制语句中使用非布尔值作为条件是很常见的错误来源。","isLeft":true},"1":{"objectClass":"MindNode","ID":"3B42M","lineColorHex":"#37C45A","text":"2. 数据错误\n开发者需要自己检查数据类型，确保不会发生错误。数据类型错误常发生在将意外值传给函数的时候。","isLeft":true},"objectClass":"NSArray"},"text":"5.识别错误\n因为JavaScript是松散类型的，不会验证函数参数，所以很多错误只有在代码真正运行起来时才会出现。要注意三种类型的错误，类型转换错误数据类型错误通信错误。上面这几种错误会在特定情况下，在没有对值进行充分检测时发生。","isLeft":true,"maxWidthLine":306},"objectClass":"NSArray"},"text":"错误处理","isLeft":true},"4":{"objectClass":"MindNode","ID":"E65O0","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"15W43","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"2V2K4","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"YG6I7","lineColorHex":"#1BD6E7","text":"send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传null，因为这个参数在某些浏览器中是必需的。","isLeft":true},"1":{"objectClass":"MindNode","ID":"VXSW1","lineColorHex":"#1BD6E7","text":"收到响应后，XHR对象以下属性会被填上数据。\nresponseText：作为响应体返回的文本。\nresponseXML\nstatus：响应的HTTP状态。\nstatusText：响应的HTTP状态描述。","isLeft":true},"2":{"objectClass":"MindNode","ID":"XM96Y","lineColorHex":"#1BD6E7","text":"XHR对象有一个readyState属性，表示当前处在请求/响应过程的哪个阶段。这个属性有如下可能的值。0 1 2 3 4\n为保证跨浏览器兼容，onreadystatechange事件处理程序应该在调用open()之前赋值。\n在收到响应之前如果想取消异步请求，可以调用abort()方法.","isLeft":true},"3":{"objectClass":"MindNode","ID":"3N54C","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"UO0YM","lineColorHex":"#1BD6E7","text":"可以使用getResponseHeader()方法从XHR对象获取响应头部，只要传入要获取头部的名称即可。","isLeft":true},"objectClass":"NSArray"},"text":"Http头部\n如果需要发送额外的请求头部，可以使用setRequestHeader()方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在open()之后、send()之前调用setRequestHeader()","isLeft":true},"4":{"objectClass":"MindNode","ID":"JS97P","lineColorHex":"#1BD6E7","text":"Get请求\n发送GET请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有名/值对必须以和号（&）分隔","isLeft":true},"objectClass":"NSArray"},"text":"1.1使用XHR对象\n首先调用open方法（）这个方法接收3个参数：请求类型（\"get\"、\"post\"等）、请求URL，以及表示请求是否异步的布尔值。","isLeft":true},"1":{"objectClass":"MindNode","ID":"4R6MM","lineColorHex":"#1BD6E7","text":"1.2XMLHttpRequest Level 2\nFormData类型便于表单序列化","isLeft":true},"objectClass":"NSArray"},"text":"1.XHR对象\n通过new XMLHttpRequest生成","isLeft":true},"1":{"objectClass":"MindNode","ID":"T4A69","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"Y4W3K","lineColorHex":"#1BD6E7","text":"对于简单的请求，比如GET或POST请求，没有自定义头部，而且请求体是text/plain类型，这样的请求在发送时会有一个额外的头部叫Origin。","isLeft":true},"1":{"objectClass":"MindNode","ID":"8536R","lineColorHex":"#1BD6E7","text":"注意，无论请求还是响应都不会包含cookie信息。出于安全考虑，跨域XHR对象也施加了一些额外限制。不能使用setRequestHeader，不能发送和接受cookie，getAllRequestHeaders方法始终返回空船。","isLeft":true},"2":{"objectClass":"MindNode","ID":"RFC66","lineColorHex":"#1BD6E7","text":"预检请求","isLeft":true},"3":{"objectClass":"MindNode","ID":"324J7","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"384M6","lineColorHex":"#1BD6E7","text":"如果服务器允许带凭据的请求，那么可以在响应中包含如下HTTP头部：\nAccess-Control-Allow-Credentials: true","isLeft":true},"1":{"objectClass":"MindNode","ID":"42F25","lineColorHex":"#1BD6E7","text":"chrome浏览器因为浏览器原因，当withCredentials设置为true时，Allow-origin不能设置为*，并且如果有设置Cookie的话必须加上SameSite=None，这样Cookie才是可用的。","isLeft":true},"objectClass":"NSArray"},"text":"凭据请求\n默认情况下，跨源请求不提供凭据（cookie、HTTP认证和客户端SSL证书）。可以通过将withCredentials属性设置为true来表明请求会发送凭据。","isLeft":true},"objectClass":"NSArray"},"text":"2. 跨域资源共享\n通过XHR进行Ajax通信的一个主要限制是跨源安全策略。\nCORS背后的基本思路就是使用自定义的HTTP头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。","isLeft":true},"2":{"objectClass":"MindNode","ID":"P8R85","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"64X74","lineColorHex":"#1BD6E7","text":"1. 图片探测\n","isLeft":true},"1":{"objectClass":"MindNode","ID":"3OVM4","lineColorHex":"#1BD6E7","text":"2. JSONP\nJSONP是“JSON with padding”的简写，是在Web服务上流行的一种JSON变体。JSONP看起来跟JSON一样，只是会被包在一个函数调用里。","isLeft":true},"objectClass":"NSArray"},"text":"3. 替代性跨源技术\n虽然CORS目前已经得到广泛支持，但这些技术仍然没有过时，因为它们不需要修改服务器。","isLeft":true},"3":{"objectClass":"MindNode","ID":"V432X","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"74518","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"D171Q","lineColorHex":"#1BD6E7","text":"请求完成、资源可用时，期约会解决为一个Response对象。这个对象是API的封装，可以通过它取得相应资源。","isLeft":true},"1":{"objectClass":"MindNode","ID":"J7388","lineColorHex":"#1BD6E7","text":"2. 读取响应\n读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。这个方法返回一个期约，会解决为取得资源的完整内容。","isLeft":true},"2":{"objectClass":"MindNode","ID":"V6Z16","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"F2118","lineColorHex":"#1BD6E7","text":"可以通过response.url属性检查通过fetch()发送请求时使用的完整URL","isLeft":true},"objectClass":"NSArray"},"text":"3. 处理状态码和状态文本\n通过Response的status（状态码）和statusText（状态文本）属性检查响应状态。\n违反CORS、无网络连接、HTTPS错配及其他浏览器/网络策略问题都会导致期约被拒绝。状态码只要是200，就算成功。","isLeft":true},"3":{"objectClass":"MindNode","ID":"2HJ1O","lineColorHex":"#1BD6E7","text":"4. 自定义选项\n只使用URL时，fetch()会发送GET请求，只包含最低限度的请求头。要进一步配置如何发送请求，需要传入可选的第二个参数init对象。","isLeft":true},"objectClass":"NSArray"},"text":"1. 用法\nfetch()只有一个必需的参数input。多数情况下，这个参数是要获取资源的URL。该方法返回一个Promise对象。","isLeft":true},"1":{"objectClass":"MindNode","ID":"YTX5P","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"EF676","lineColorHex":"#1BD6E7","text":"1. 发送json\n当发现请求头定义了Content-Type，跨源 要设置mode配置项，还是报错时。要在服务端响应头中添加\"Access-Control-Allow-Headers\", \"X-Requested-With,Content-Type,mytoken\"。","isLeft":true},"1":{"objectClass":"MindNode","ID":"F5SFE","lineColorHex":"#1BD6E7","text":"","isLeft":true},"objectClass":"NSArray"},"text":"2. 常见fetch请求模式","isLeft":true},"2":{"objectClass":"MindNode","ID":"63004","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"U114X","lineColorHex":"#1BD6E7","text":"3.1 headers和map对象\nHeaders与Map类型都有get()、set()、has()和delete()等实例方法，都是键值对。","isLeft":true},"1":{"objectClass":"MindNode","ID":"IM72A","lineColorHex":"#1BD6E7","text":"3.2 headers独有特性\n初始化时，可以使用键值对形式的对象，而map不行。一个HTTP头部字段可以有多个值，而Headers对象通过append()方法支持添加多个值。在Headers实例中还不存在的头部上调用append()方法相当于调用set()。","isLeft":true},"2":{"objectClass":"MindNode","ID":"53TV4","lineColorHex":"#1BD6E7","text":"3.3 头部护卫\n某些情况下，并非所有HTTP头部都可以被客户端修改，而Headers对象使用护卫来防止不被允许的修改。","isLeft":true},"objectClass":"NSArray"},"text":"3. headers对象\nHeaders对象是所有外发请求和入站响应头部的容器。可以通过Request.prototype.headers，Response.prototype.headers访问到都是可以修改的属性。","isLeft":true},"3":{"objectClass":"MindNode","ID":"H57Q2","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"5N134","lineColorHex":"#1BD6E7","text":"1. 创建Request对象\n可以通过构造函数初始化Request对象。为此需要传入一个input参数，一般是URL。也接受第二配置参数，没有在配置对象中涉及到的值会使用默认值。","isLeft":true},"1":{"objectClass":"MindNode","ID":"820D1","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"8LUO1","lineColorHex":"#1BD6E7","text":"不管是用哪一种方式克隆，在请求体被读取之后再克隆会导致抛出TypeError。","isLeft":true},"objectClass":"NSArray"},"text":"2. 克隆Request对象\nFetch API提供了两种方法，第一将Request实例做为参数传入Request构造函数中，第二使用clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。","isLeft":true},"2":{"objectClass":"MindNode","ID":"LQ445","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"D8C2Q","lineColorHex":"#1BD6E7","text":"要想基于包含请求体的相同Request对象多次调用fetch()，必须在第一次发送fetch()请求前调用clone()：","isLeft":true},"objectClass":"NSArray"},"text":"3. 在Fetch中使用Request对象\n在调用fetch()时，可以传入已经创建好的Request实例而不是URL。与Request构造函数一样，传给fetch()的init对象会覆盖传入请求对象的值。","isLeft":true},"objectClass":"NSArray"},"text":"4. Request对象\nRequest对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。","isLeft":true},"4":{"objectClass":"MindNode","ID":"34SH8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"6TQ90","lineColorHex":"#1BD6E7","text":"1. 创建Response对象\nResponse构造函数接收一个可选的body参数。这个body可以是null，等同于fetch()参数init中的body。还可以接收一个可选的init对象，可以包含headers，status，statusText","isLeft":true},"1":{"objectClass":"MindNode","ID":"86N93","lineColorHex":"#1BD6E7","text":"2. 读取响应内容\nrespense有几个只读属性。","isLeft":true},"2":{"objectClass":"MindNode","ID":"0E36M","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"WLVV1","lineColorHex":"#1BD6E7","text":"如果响应对象的bodyUsed属性为true（即响应体已被读取），则不能再创建这个对象的副本。","isLeft":true},"1":{"objectClass":"MindNode","ID":"W7B83","lineColorHex":"#1BD6E7","text":"有响应体的Response对象只能读取一次。（不包含响应体的Response对象不受此限制。）也就是只能调用一次text方法。","isLeft":true},"objectClass":"NSArray"},"text":"3. 克隆Response对象\n克隆Response对象的主要方式是使用clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用。","isLeft":true},"objectClass":"NSArray"},"text":"5. Response对象\n这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。","isLeft":true},"objectClass":"NSArray"},"text":"Fetch API\nFetch API能够执行XMLHttpRequest对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等现代Web工具中使用。Fetch API则必须是异步","isLeft":true},"objectClass":"NSArray"},"text":"网络请求与远程资源","isLeft":true},"5":{"objectClass":"MindNode","ID":"ZG44H","lineColorHex":"#FFC700","text":"模块","isLeft":true},"6":{"objectClass":"MindNode","ID":"7V436","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"NU782","lineColorHex":"#DC306C","text":"1.WebStorage","isLeft":true},"objectClass":"NSArray"},"text":"客户端存储","isLeft":true},"7":{"objectClass":"MindNode","ID":"811QK","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7D7DG","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"H9V2X","lineColorHex":"#BF58F5","text":"ArrayBuffer()是一个普通的JavaScript构造函数，可用于在内存中分配特定数量的字节空间。","isLeft":true},"1":{"objectClass":"MindNode","ID":"M3553","lineColorHex":"#BF58F5","text":"Arraybuffer一经创建就不能再调整大小，不过，可以使用slice()复制其全部或部分到一个新实例中。","isLeft":true},"objectClass":"NSArray"},"text":"1. ArrayBuffer\nFloat32Array是一种视图，可以允许JavaScript运行时访问一块名为ArrayBuffer的预分配内存。ArrayBuffer是所有定型数组及视图引用的基本单位","isLeft":true},"1":{"objectClass":"MindNode","ID":"1AI63","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"V2104","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"S446Q","lineColorHex":"#BF58F5","text":"DataView为上表中的每种类型都暴露了get和set方法，这些方法使用byteOffset（字节偏移量）定位要读取或写入值的位置。","isLeft":true},"objectClass":"NSArray"},"text":"2.1 elementType\nDataView对存储在缓冲内的数据类型没有预设。它暴露的API强制开发者在读、写时指定一个ElementType。","isLeft":true},"objectClass":"NSArray"},"text":"2.DataView\n第一种允许你读写ArrayBuffer的视图是DataView。这个视图专为文件I/O和网络I/O设计，其API支持对缓冲数据的高度控制。必须在对已有的ArrayBuffer读取或写入时才能创建DataView实例。","isLeft":true},"objectClass":"NSArray"},"text":"定型数组","isLeft":true},"8":{"objectClass":"MindNode","ID":"W1R7L","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"11UR8","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"2NFE0","lineColorHex":"#26BBFF","text":"初始化之后，可以使用set()方法再添加键/值对。另外，可以使用get()和has()进行查询，可以通过size属性获取映射中的键/值对的数量，还可以使用delete()和clear()删除值。","isLeft":true},"1":{"objectClass":"MindNode","ID":"7DBN4","lineColorHex":"#26BBFF","text":"set()方法返回映射实例，因此可以把多个操作连缀起来。与Object只能使用数值、字符串或符号作为键不同，Map可以使用任何JavaScript数据类型作为键。","isLeft":true},"2":{"objectClass":"MindNode","ID":"2HNR2","lineColorHex":"#26BBFF","text":"与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变，也就是说map也会修改。","isLeft":true},"objectClass":"NSArray"},"text":"1.Map 基本API\n使用new关键字和Map构造函数可以创建一个空映射。如果想在创建的同时初始化实例，可以给Map构造函数传入一个可迭代对象，需要包含键/值对数组。","isLeft":true},"1":{"objectClass":"MindNode","ID":"3RTWD","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"4Z3Q5","lineColorHex":"#26BBFF","text":"键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份。","isLeft":true},"objectClass":"NSArray"},"text":"2. map顺序和迭代\n与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。","isLeft":true},"2":{"objectClass":"MindNode","ID":"S1LI2","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"RZK26","lineColorHex":"#26BBFF","text":"3.1 基本API\n可以使用new关键字实例化一个空的WeakMap。弱映射中的键只能是Object或者继承自Object的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。","isLeft":true},"1":{"objectClass":"MindNode","ID":"2XYWK","lineColorHex":"#26BBFF","text":"3.2 弱建\n如果一个对象键没有别的引用，在执行完weakmap的代码后就被会当作垃圾回收，键值对也从弱映射中消失。","isLeft":true},"objectClass":"NSArray"},"text":"3. weakmapa","isLeft":true},"3":{"objectClass":"MindNode","ID":"R2N96","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"8YP88","lineColorHex":"#26BBFF","text":"4.1 基本API\n","isLeft":true},"objectClass":"NSArray"},"text":"4. Set\nECMAScript 6新增的Set是一种新集合类型，为这门语言带来集合数据结构。","isLeft":true},"objectClass":"NSArray"},"text":"Map和Set","isLeft":true},"9":{"objectClass":"MindNode","ID":"J13L5","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"I0N67","lineColorHex":"#37C45A","text":"1. 理解迭代\n循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。","isLeft":true},"1":{"objectClass":"MindNode","ID":"EQ2CW","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"94H6P","lineColorHex":"#37C45A","text":"任何实现Iterable接口的数据结构都可以被实现Iterator（迭代器）接口的结构“消费”（consume）。","isLeft":true},"1":{"objectClass":"MindNode","ID":"HD17Y","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"H56N5","lineColorHex":"#37C45A","text":"arr[Symbol.iterator] 是一个函数，调用这个函数会生成一个迭代器。许多原生语言结构会自动调用这个函数生成迭代器。","isLeft":true},"objectClass":"NSArray"},"text":"2.1 可迭代协议\n实现Iterable接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的Symbol.iterator作为键。","isLeft":true},"2":{"objectClass":"MindNode","ID":"4NEDS","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"7M71L","lineColorHex":"#37C45A","text":"next()方法返回的迭代器对象IteratorResult包含两个属性：done和value。done是一个布尔值，表示是否还可以再次调用next()取得下一个值；value包含可迭代对象的下一个值（done为false），或者undefined（done为true）。done: true状态称为“耗尽”。","isLeft":true},"1":{"objectClass":"MindNode","ID":"RP26R","lineColorHex":"#37C45A","text":"如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象。","isLeft":true},"objectClass":"NSArray"},"text":"2.2 迭代器协议\n迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。","isLeft":true},"objectClass":"NSArray"},"text":"2. 迭代器模式\n可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的Iterable接口，基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序","isLeft":true},"2":{"objectClass":"MindNode","ID":"3W7C1","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"V1268","lineColorHex":"#37C45A","text":"因为每个迭代器也实现了Iterable接口，所以它们可以用在任何期待可迭代对象的地方，比如for-of循环","isLeft":true},"objectClass":"NSArray"},"text":"3. 自定义迭代器\n与Iterable接口类似，任何实现Iterator接口的对象都可以作为迭代器使用。","isLeft":true},"3":{"objectClass":"MindNode","ID":"8BQG4","lineColorHex":"#37C45A","text":"4. 停止迭代器\n","isLeft":true},"4":{"objectClass":"MindNode","ID":"C506Q","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"6MMGN","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"G25N5","lineColorHex":"#37C45A","text":"value属性是生成器函数的返回值，默认值为undefined，可以通过生成器函数的返回值指定\n生成器函数只会在初次调用next()方法后开始执行，调用生成器函数并不会执行函数体。","isLeft":true},"objectClass":"NSArray"},"text":"调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了Iterator接口，因此具有next()方法。\nnext()方法的返回值类似于迭代器，有一个done属性和一个value属性。","isLeft":true},"1":{"objectClass":"MindNode","ID":"92J4R","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"32541","lineColorHex":"#37C45A","text":"通过yield关键字退出的生成器函数会处在done: false状态；通过return关键字退出的生成器函数会处于done:true状态。此时的yield关键字有点像函数的中间返回语句，它生成的值会出现在next()方法返回的对象里。","isLeft":true},"1":{"objectClass":"MindNode","ID":"J2J5Z","lineColorHex":"#37C45A","text":"生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用next()不会影响其他生成器","isLeft":true},"2":{"objectClass":"MindNode","ID":"7LO61","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"X47IO","lineColorHex":"#37C45A","text":"在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现。","isLeft":true},"objectClass":"NSArray"},"text":"1. 生成器对象作为可迭代对象\n在生成器对象上显式调用next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便。","isLeft":true},"3":{"objectClass":"MindNode","ID":"4J9P8","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"QWHB5","lineColorHex":"#37C45A","text":"上一次让生成器函数暂停的yield关键字会接收到传给next()方法的第一个值。这里有个地方不太好理解——第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数","isLeft":true},"objectClass":"NSArray"},"text":"2. 使用yield实现输入和输出\n除了可以作为函数的中间返回语句使用，yield关键字还可以作为函数的中间参数使用。","isLeft":true},"4":{"objectClass":"MindNode","ID":"241G5","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"32H9V","lineColorHex":"#37C45A","text":"yield＊的值是关联迭代器返回done: true时的value属性。对于普通迭代器来说，这个值是undefined。对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值。","isLeft":true},"objectClass":"NSArray"},"text":"3. 产生可迭代对象\n可以使用星号增强yield的行为，让它能够迭代一个可迭代对象，从而一次产出一个值。","isLeft":true},"objectClass":"NSArray"},"text":"5.2 通过yield中断执行\nyield关键字可以让生成器停止和开始执行，也是生成器最有用的地方。","isLeft":true},"objectClass":"NSArray"},"text":"5.生成器基础\n生成器的形式是一个函数，函数名称前面加一个星号（＊）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。","isLeft":true},"objectClass":"NSArray"},"text":"迭代器和生成器","isLeft":true},"objectClass":"NSArray"},"text":"JavaScript","expandLeftEnable":true},"ID":"0Q187","style":100}