{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"U55N4","rootPoint":{"objectClass":"CGPoint","x":360,"y":4675.25},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"X8TYF","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"9GDHG","lineColorHex":"#DC306C","text":"1. 使用http协议访问web\n在浏览器的地址栏输入URL，web浏览器从服务器获取资源等信息，通过发送请求获取资源的web浏览器等都成为客户端。\n\nWeb使用HTTP 超文本传输协议 作为规范。"},"1":{"objectClass":"MindNode","ID":"86VJY","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"VEW0Y","lineColorHex":"#DC306C","text":"最重要的一点就是分层：应用层、传输层、网络层、数据链路层。"},"objectClass":"NSArray"},"text":"2. 网络基础TCP/IP\n网络是在TCP/IP协议族的基础上运作的，http协议是它的子集。"},"2":{"objectClass":"MindNode","ID":"915F3","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"H8ZQ4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"A258A","lineColorHex":"#DC306C","text":"IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。"},"objectClass":"NSArray"},"text":"IP协议：\n在网络层，把各种数据包传送给对方。保证能送到对方要满足各种条件，两个最重要的条件是IP地址和MAC地址。"},"1":{"objectClass":"MindNode","ID":"EK29H","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"8QKQ5","lineColorHex":"#DC306C","text":"三次握手","markType":7},"objectClass":"NSArray"},"text":"TCP协议：\n按层次分，TCP位于传输层，提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理"},"2":{"objectClass":"MindNode","ID":"IBZ44","lineColorHex":"#DC306C","text":"DNS服务：\nDNS服务也是位于应用层的协议。提供域名到IP地址之间的解析服务。"},"objectClass":"NSArray"},"text":"TCP、IP、DNS协议"},"3":{"objectClass":"MindNode","ID":"DS421","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7Y2G7","lineColorHex":"#DC306C","text":"登录信息认证是可选项，指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。"},"1":{"objectClass":"MindNode","ID":"6743W","lineColorHex":"#DC306C","text":"服务器地址：\n地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名"},"2":{"objectClass":"MindNode","ID":"R2H3Y","lineColorHex":"#DC306C","text":"服务器端口号：\n指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。"},"3":{"objectClass":"MindNode","ID":"RJO5C","lineColorHex":"#DC306C","text":"带层次的文件路径\n指定服务器上的文件路径来定位特指的资源。"},"objectClass":"NSArray"},"text":"URI格式\nhttp://ueser:pass@www.example.jp:80/dir/index.htm?uid=1#ch1"},"objectClass":"NSArray"},"text":"第一章 web以及网络基础"},"1":{"objectClass":"MindNode","ID":"Y64UV","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"88891","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"32RKY","lineColorHex":"#BF58F5","text":"HTTP协议和TCP/IP协议族用于客户端和服务器之间的通信。\n请求访问文本或图像等资源的一段为客户端，而提供资源响应的一端为服务器。"},"objectClass":"NSArray"},"text":"1. HTTP协议用于客户端和服务器端之间的通信"},"1":{"objectClass":"MindNode","ID":"7YB8Q","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6BTH3","lineColorHex":"#BF58F5","text":"HTTP协议规定，请求从客户端发出，最后服务器响应该请求并返回。\n请求报文内容：\nGET /index.html HTTP/1.1\nHost: hackr.jp。\n开头的GET标识请求访问服务器的类型，称为方法。随后的字符串/index.htm指明了请求访问的资源对象，也叫做请求URI（request-URI）。最后的HTTP/1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。"},"1":{"objectClass":"MindNode","ID":"W1GJ1","lineColorHex":"#BF58F5","text":"请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。"},"2":{"objectClass":"MindNode","ID":"I7E75","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"8FU32","lineColorHex":"#BF58F5","text":"响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。"},"objectClass":"NSArray"},"text":"响应报文：\nHTTP/1.1 200 OK\nDate: TUe......\nContent-Length : 362\n200 ok表示请求的处理结果的状态码和原因短语。下一行显示了创建响应的日期时间，是首部字段内一个属性。"},"objectClass":"NSArray"},"text":"2. 通过请求和响应的交换达成通信"},"2":{"objectClass":"MindNode","ID":"PMR5U","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1LHN4","lineColorHex":"#BF58F5","text":"使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。"},"objectClass":"NSArray"},"text":"3. HTTP是不保存状态的协议"},"3":{"objectClass":"MindNode","ID":"74775","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"AJ123","lineColorHex":"#BF58F5","text":"当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。指定请求URI的方式有很多。\nURI为完整的请求URI\nhttp://hacker.jp/index.html HTTP/1.1"},"objectClass":"NSArray"},"text":"4. 请求URI定位资源"},"4":{"objectClass":"MindNode","ID":"536S3","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"8747V","lineColorHex":"#BF58F5","text":"1. GET获取资源\nGET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回。"},"1":{"objectClass":"MindNode","ID":"165U2","lineColorHex":"#BF58F5","text":"2. POST：传输实体主体\nPOST的主要目的并不是获取响应的主体内容。"},"2":{"objectClass":"MindNode","ID":"5E2VW","lineColorHex":"#BF58F5","text":"3. PUT：传输文件\nPUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。"},"3":{"objectClass":"MindNode","ID":"537W6","lineColorHex":"#BF58F5","text":"4. HEAD：获得报文首部\nHEAD方法和GET方法一样，只是不返回报文主体部分。返回响应首部。"},"4":{"objectClass":"MindNode","ID":"3B3CK","lineColorHex":"#BF58F5","text":"5. DELETE：删除文件\nDELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。"},"objectClass":"NSArray"},"text":"5. 告诉服务器意图的HTTP方法"},"5":{"objectClass":"MindNode","ID":"7CW9B","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"B2L2K","lineColorHex":"#BF58F5","text":"HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP PersistentConnections，也称为HTTP keep-alive或HTTPconnection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。"},"objectClass":"NSArray"},"text":"6. 持久连接节省通信量"},"6":{"objectClass":"MindNode","ID":"NJ4J4","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"24X7R","lineColorHex":"#BF58F5","text":"Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。"},"1":{"objectClass":"MindNode","ID":"15ZNG","lineColorHex":"#BF58F5","text":"根据服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。"},"objectClass":"NSArray"},"text":"7. 使用cookie的状态管理"},"objectClass":"NSArray"},"text":"第二章简单的HTTP协议"},"2":{"objectClass":"MindNode","ID":"866Q5","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"672MW","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"EP7WV","lineColorHex":"#26BBFF","text":"HTTP报文分为报文首部和报文主题，通常不一定要报文主体。"},"objectClass":"NSArray"},"text":"1.HTTP报文\n用于HTTP协议交互得信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。报文本身是多行数据构成得字符串文本。"},"1":{"objectClass":"MindNode","ID":"GQL5Y","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"UTKP0","lineColorHex":"#26BBFF","text":"请求行：包含用于请求的方法，请求URI和HTTP版本\n\n状态行：包含表明响应结果状态码，原因短语和HTTP版本\n\n首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部。\n\n其他：可能包含HTTP的RFC里未定义的首部（Cookie等）。"},"objectClass":"NSArray"},"text":"2. 请求报文及响应报文的解构\n请求报文的报文首部由请求行、请求首部字段、通用首部字段、实体首部字段组成。\n\n响应报文的报文首部由状态行、响应首部字段、通用首部字段、实体首部字段组成。"},"2":{"objectClass":"MindNode","ID":"9RJKR","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"BEP0U","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"3Q51Z","lineColorHex":"#26BBFF","text":"通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。"},"objectClass":"NSArray"},"text":"1. 报文（message）\nHTTP通信中的基本单位，8位组字节流组成，通过HTTP通信传输。\n2. 实体\n作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。"},"1":{"objectClass":"MindNode","ID":"MF734","lineColorHex":"#26BBFF","text":"2. 压缩传输的内容编码\n我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。"},"2":{"objectClass":"MindNode","ID":"6Y55D","lineColorHex":"#26BBFF","text":"3. 分割发送的分块传输编码\n在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。\n这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。"},"objectClass":"NSArray"},"text":"3. 编码提升传输速率\n通过在传输时编码，能有效地处理大量的访问请求。"},"3":{"objectClass":"MindNode","ID":"1K69V","lineColorHex":"#26BBFF","text":"4. 发送多种数据的多部份对象集合\n","markType":5},"4":{"objectClass":"MindNode","ID":"V47S8","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"23108","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"X0DVK","lineColorHex":"#26BBFF","text":"针对范围请求，响应会返回状态码为206 PartialContent的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。"},"objectClass":"NSArray"},"text":"要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（RangeRequest）。\n\n执行范围请求时，会用到首部字段Range来指定资源的byte范围。byte范围的指定形式如下。\n比如Range：bytes=5001-10000\nbytes=5001-\nbytes=-3000，5000-7000"},"objectClass":"NSArray"},"text":"5. 获取部分内容的范围请求\n解决下载过程中网络中断导致从头开始下载的问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。"},"5":{"objectClass":"MindNode","ID":"W2643","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"73Y35","lineColorHex":"#26BBFF","text":"访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商（ContentNegotiation）。\n\n内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。"},"objectClass":"NSArray"},"text":"6. 内容协商返回最合适的内容"},"objectClass":"NSArray"},"text":"第三章 HTTP报文内的HTTP信息"},"3":{"objectClass":"MindNode","ID":"59660","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"A3MF7","lineColorHex":"#37C45A","text":"1. 状态码告知从服务器端返回的请求结果\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。数字中的第一位指定了响应类别，后两位无分类。有五种：\n1xx：接收的请求正在处理\n2xx：请求正常处理完毕\n3xx：需要进行附加操作以完成请求\n4xx：服务器无法处理请求\n5xx：服务器处理请求出错"},"1":{"objectClass":"MindNode","ID":"O6FG6","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"FUL6J","lineColorHex":"#37C45A","text":"204 No Content\n该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。"},"1":{"objectClass":"MindNode","ID":"KS4LK","lineColorHex":"#37C45A","text":"206 Partial Content\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。"},"objectClass":"NSArray"},"text":"2. 2xx成功\n在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。"},"2":{"objectClass":"MindNode","ID":"T3142","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"V4HX4","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"4F8K7","lineColorHex":"#37C45A","text":"比如 http://example.com/sample\n最后没加/ 就会产生301状态码"},"objectClass":"NSArray"},"text":"301 Moved Permanently\n永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。"},"1":{"objectClass":"MindNode","ID":"DMI6Q","lineColorHex":"#37C45A","text":"302 Found\n临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。"},"2":{"objectClass":"MindNode","ID":"J338I","lineColorHex":"#37C45A","text":"303 See Other\n该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。","summaries":{"0":{"objectClass":"NodeSummary","ID":"4F8K7","text":"当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"3":{"objectClass":"MindNode","ID":"3YK2O","lineColorHex":"#37C45A","text":"304 Not Modified\n该状态码表示客户端发送附带条件的请求[插图]时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存"},"objectClass":"NSArray"},"text":"3. 3xx重定向\n3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。"},"3":{"objectClass":"MindNode","ID":"R33NQ","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"2AM26","lineColorHex":"#37C45A","text":"400 Bad Request\n该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。"},"1":{"objectClass":"MindNode","ID":"P11D4","lineColorHex":"#37C45A","text":"401 Unauthorized\n该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。"},"2":{"objectClass":"MindNode","ID":"UK55V","lineColorHex":"#37C45A","text":"403 Forbidden\n该状态码表明对请求资源的访问被服务器拒绝了。"},"3":{"objectClass":"MindNode","ID":"4Y077","lineColorHex":"#37C45A","text":"404 Not Found\n该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。"},"objectClass":"NSArray"},"text":"4. 4xx客户端错误\n4XX的响应结果表明客户端是发生错误的原因所在。","maxWidthLine":306},"4":{"objectClass":"MindNode","ID":"GG5S6","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"SFL1F","lineColorHex":"#37C45A","text":"500 Internal Server Error\n该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。"},"1":{"objectClass":"MindNode","ID":"PU7NZ","lineColorHex":"#37C45A","text":"503 Service Unavailable\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。"},"objectClass":"NSArray"},"text":"5. 5xx服务器错误"},"objectClass":"NSArray"},"text":"第四章 返回结果的HTTP状态码"},"4":{"objectClass":"MindNode","ID":"23HKH","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"3G882","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"ESKQ0","lineColorHex":"#1BD6E7","text":"所以，如果一台服务器内托管了www.tricorder.jp和www.hackr.jp这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。\n因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。"},"objectClass":"NSArray"},"text":"1. 用单台虚拟主机实现多个域名\n在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问了。"},"1":{"objectClass":"MindNode","ID":"6E2YW","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"6W4PI","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"P45P6","lineColorHex":"#1BD6E7","text":"缓存代理：\n代理转发响应时，缓存代理（CachingProxy）会预先将资源的副本（缓存）保存在代理服务器上。再次请求相同资源时，就可以从代理服务器获取，不需要从源服务器获取资源。"},"1":{"objectClass":"MindNode","ID":"2511K","lineColorHex":"#1BD6E7","text":"透明代理：\n转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（TransparentProxy）。"},"objectClass":"NSArray"},"text":"1. 代理\n代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。\n\n每次通过代理服务器转发请求或响应式，会追加写入Via首部\n代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。"},"1":{"objectClass":"MindNode","ID":"7D575","lineColorHex":"#1BD6E7","text":"2. 网关\n网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务。"},"2":{"objectClass":"MindNode","ID":"T317P","lineColorHex":"#1BD6E7","text":"3. 隧道\n隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。"},"objectClass":"NSArray"},"text":"2. 通信数据转发程序：代理、网关、隧道\nHTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。"},"2":{"objectClass":"MindNode","ID":"Q11NY","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"N4Y71","lineColorHex":"#1BD6E7","text":"1. 缓存的有效期限\n即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。\n\n即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。"},"1":{"objectClass":"MindNode","ID":"5M5IH","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"LHIJ5","lineColorHex":"#1BD6E7","text":"浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。"},"objectClass":"NSArray"},"text":"2. 客户端缓存\n缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer程序为例，把客户端缓存称为临时网络文件（TemporaryInternet File）。"},"objectClass":"NSArray"},"text":"3. 保存资源的缓存\n缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。"},"objectClass":"NSArray"},"text":"第五章 与HTTP写作的Web服务器"},"5":{"objectClass":"MindNode","ID":"8A687","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"9819W","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"2M3TP","lineColorHex":"#FFC700","text":"HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。\n\n在报文众多的字段当中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。"},"1":{"objectClass":"MindNode","ID":"25JTE","lineColorHex":"#FFC700","text":"HTTP请求报文：\n请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。\n其中请求行包含了方法、URI、HTTP版本，HTTP首部字段包括请求、通用、实体首部字段。"},"2":{"objectClass":"MindNode","ID":"YT5KC","lineColorHex":"#FFC700","text":"HTTP响应报文：\n响应中，HTTP报文由状态行包含的HTTP版本、状态码、HTTP首部字段构成。"},"objectClass":"NSArray"},"text":"1. HTTP报文首部"},"1":{"objectClass":"MindNode","ID":"1878R","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"7DR82","lineColorHex":"#FFC700","text":"1. HTTP首部字段传递重要信息\n使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。"},"1":{"objectClass":"MindNode","ID":"RN3QT","lineColorHex":"#FFC700","text":"2. HTTP首部字段结构\nHTTP首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔。\n比如HTTP首部中以Content-Type这个字段表示报文主题的对象类型。\nContent-Type：text/html\n\n首部字段可以有多个字段值与之对应。\nKeep-Alive：timeout=15，max=100"},"2":{"objectClass":"MindNode","ID":"V8B2V","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"26UQM","lineColorHex":"#FFC700","text":"1、通用首部字段（General Header Fields）\n请求报文和响应报文两方都会使用的首部。\n2、请求首部字段（Request Header Fields）\n从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n3、响应首部字段（Response Header Fields）\n从服务器端向客户端返回响应报文时使用的首部。\n4、实体首部字段（Entity Header Fields）\n针对请求报文和响应报文的实体部分使用的首部。"},"objectClass":"NSArray"},"text":"3.  4种HTTP首部字段类型"},"3":{"objectClass":"MindNode","ID":"037WK","lineColorHex":"#FFC700","text":"4. 首部字段一览表","markType":7},"4":{"objectClass":"MindNode","ID":"M3649","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"CYT51","lineColorHex":"#FFC700","text":"还有Cookie、Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率也很高。"},"objectClass":"NSArray"},"text":"5.非HTTP/1.1首部字段"},"5":{"objectClass":"MindNode","ID":"77EC1","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"7PN28","lineColorHex":"#FFC700","text":"HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型。"},"objectClass":"NSArray"},"text":"6.End-to-end首部和Hop-by-hop首部"},"objectClass":"NSArray"},"text":"2. HTTP首部字段"},"2":{"objectClass":"MindNode","ID":"66SB9","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"2Y47N","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"J4717","lineColorHex":"#FFC700","text":"可用的指令按请求和响应分类"},"objectClass":"NSArray"},"text":"1.Cache-Control\n通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。","markType":7},"1":{"objectClass":"MindNode","ID":"3P472","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"0F453","lineColorHex":"#FFC700","text":"1. 控制不再转发给代理的首部字段\nConnection：不再转发的首部字段名使用Connection首部字段，可控制不再转发给代理的首部字段（即Hop-by-hop首部）。"},"1":{"objectClass":"MindNode","ID":"YE583","lineColorHex":"#FFC700","text":"2. 管理持久连接\nHTTP/1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。\n\n如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive。"},"objectClass":"NSArray"},"text":"2. Connection\n有两个作用，控制不再转发给代理的首部字段和管理持久连接。"},"2":{"objectClass":"MindNode","ID":"19044","lineColorHex":"#FFC700","text":"3. Date\n首部字段Date表明创建HTTP报文的日期和时间。"},"3":{"objectClass":"MindNode","ID":"1FOV6","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"8SR71","lineColorHex":"#FFC700","text":"pragma：no-cache\n客户端会要求所有的中间服务器不返回缓存的资源。"},"objectClass":"NSArray"},"text":"4. Pragma\n该首部字段属于通用首部字段，但只用在客户端发送的请求中。"},"4":{"objectClass":"MindNode","ID":"1B78D","lineColorHex":"#FFC700","text":"5.Trailer\n首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。"},"5":{"objectClass":"MindNode","ID":"7GH70","lineColorHex":"#FFC700","text":"6.Transfer-Encoding\n首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。"},"6":{"objectClass":"MindNode","ID":"0UCV7","lineColorHex":"#FFC700","text":"7.Upgrade\n首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。"},"7":{"objectClass":"MindNode","ID":"5R2RU","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"R44Z4","lineColorHex":"#FFC700","text":"报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。\nVia首部是为了追踪传输路径，所以经常会和TRACE方法一起使用。"},"objectClass":"NSArray"},"text":"8.Via\n使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。"},"8":{"objectClass":"MindNode","ID":"7H504","lineColorHex":"#FFC700","text":"9.Warning\n该首部通常会告知用户一些与缓存相关的问题的警告。"},"objectClass":"NSArray"},"text":"3. HTTP/1.1 通用首部字段"},"3":{"objectClass":"MindNode","ID":"92DV8","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"80R41","lineColorHex":"#FFC700","text":"1.Accept\n"},"objectClass":"NSArray"},"text":"4. 请求首部字段"},"objectClass":"NSArray"},"text":"第六章 HTTP首部"},"objectClass":"NSArray"},"text":"HTTP"},"ID":"JVH75","style":100}