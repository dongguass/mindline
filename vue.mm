{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"D9PDB","rootPoint":{"objectClass":"CGPoint","x":360,"y":5694.25},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"CGQ2Z","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"78801","lineColorHex":"#DC306C","text":"M：模型 对应data中的数据\nV： 视图（view） 模板\nVM： 视图模型Vue实例对象"},"1":{"objectClass":"MindNode","ID":"48WCI","lineColorHex":"#DC306C","text":"VM也就是Vue实例对象上的所有属性，以及它原型身上的所有方法都可以直接使用。"},"objectClass":"NSArray"},"text":"MVVM模型"},"1":{"objectClass":"MindNode","ID":"S790Q","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"IW84M","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"12HG0","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"XVK2Y","lineColorHex":"#DC306C","text":"计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。"},"objectClass":"NSArray"},"text":"\n\n\n我们在计算属性computed中声明了一个reversedMessage计算属性，它在标签中表现为{{ reversedMessage }}。我们提供的函数，将用作它的getter函数！！！\n这个getter函数理解很重要，在任何表达式中只要用到这个计算属性，就会根据get函数体中的代码进行计算并通过return返回一个计算之后的值。"},"1":{"objectClass":"MindNode","ID":"CELST","lineColorHex":"#DC306C","text":"computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }"},"objectClass":"NSArray"},"text":"\n\n\n\n计算属性：\n1. 定义：要用的属性不存在于data或者props中，要通过已有属性计算得来\n2. 原理： 底层借用Object.defineproperty方法提供的getter和setter\n3. get函数什么时候执行？\n   初次读取时会执行一次\n   当依赖的数据发生改变的时候会被再次调用\n4. 计算属性会出现在vm上，直接调用即可\n5. 如果计算属性要被修改，必须写set函数去响应修改，且set要引起计算时依赖的数据发生改变。"},"1":{"objectClass":"MindNode","ID":"7FDY4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"O11LQ","lineColorHex":"#DC306C","text":"1.\n完整的写法：\nwatch：{\n     info:{ handler(newvalue,oldvalue){\n            执行一些操作\n}}\n}在watch中，被监视的数据发生改变时会传递两个参数newValue和oldValue给回调函数"},"1":{"objectClass":"MindNode","ID":"ZZBDK","lineColorHex":"#DC306C","text":"2。\nvm.$watch(被监视的数据，{配置对象})\n这也是一种监视方式"},"2":{"objectClass":"MindNode","ID":"08VN3","lineColorHex":"#DC306C","text":"3. 监视的属性必须存在，才能进行监视，不止是data中的属性，还可以是计算属性。"},"3":{"objectClass":"MindNode","ID":"88H13","lineColorHex":"#DC306C","text":"4. 深度监视\n 1. vue中的watch默认不监测对象内部值得改变。\n2. 配置deep： true可以监测对象内部值改变，多层次得属性比如对象。\n\n3. Vue自身可以监测对象内部值得改变，但是Vue提供得watch不行\n4. 根据数据结构决定是否采用深度监视。"},"4":{"objectClass":"MindNode","ID":"44388","lineColorHex":"#DC306C","text":"5. 简写写法\n如果没有配置项的时候，可以简写成函数的写法。"},"objectClass":"NSArray"},"text":"watch监听属性，是监听一个存在并且可能发生改变的值，然后在监听函数中去改变可能因为这个发生改变的值而改变的值。"},"2":{"objectClass":"MindNode","ID":"NS7KM","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"R1GEU","lineColorHex":"#DC306C","text":"1. computed能完成的watch也能完成\n2. watch能完成的功能。computed不一定能完成比如watch能执行异步操作\n\n重要的原则\n3. 所有被Vue管理的函数，最好写成普通函数，这样this指向的就是Vue实例或者组件实例\n4. 不被Vue管理的函数写成箭头函数，这样this才指向vm。"},"objectClass":"NSArray"},"text":"computed和watch之间的区别"},"objectClass":"NSArray"},"text":"计算属性和监听器"},"2":{"objectClass":"MindNode","ID":"1MVY1","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"F5W14","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2TBG8","lineColorHex":"#DC306C","text":"1. 对象语法\nv-bind:class=\"{ active: isActive } avtive这个类存在与否取决于isActive。\n我们更可以在这里绑定一个返回对象的计算属性，返回的对象中属性名是类名，属性值是决定这个属性能否存在的各种数据。"},"1":{"objectClass":"MindNode","ID":"R0X11","lineColorHex":"#DC306C","text":"2. 还可以使用三元表达式\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>"},"objectClass":"NSArray"},"text":"绑定class，一定要注意的是它v-bind：class只能控制一个类是否在标签上生效，不能想着通过它改变class中的样式。"},"1":{"objectClass":"MindNode","ID":"OLKTD","lineColorHex":"#DC306C","text":"绑定style\nv-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。\n\n通过v-bind：style可以添加或者修改样式！"},"objectClass":"NSArray"},"text":"绑定class相关问题"},"3":{"objectClass":"MindNode","ID":"IO296","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"MD46G","lineColorHex":"#BF58F5","text":"v-for指令：\n 1. 用于展示列表数据\n2. 语法： v-for=“(item, index) in xxx”:key=\"yyy\"\n3. 可遍历数组对象字符串指定次数。 "},"1":{"objectClass":"MindNode","ID":"2S1IN","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"Q4B1K","lineColorHex":"#BF58F5","text":"1。虚拟DOM中key的作用:\nkey是虚拟bOw对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下:"},"1":{"objectClass":"MindNode","ID":"W2C3B","lineColorHex":"#BF58F5","text":"2.对比规则:\n(1).旧虚拟DOM中找到了与新虚拟DOM相同的key:\n若虚拟DOM中内容没变,直接使用之前的真实DOM !\n2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DON。\n\n(2).旧虚拟DOM中未找到与新虚拟DOM相同的key\n创建新的真实DOM,随后渲染到到页面。"},"2":{"objectClass":"MindNode","ID":"SV6S8","lineColorHex":"#BF58F5","text":"3．用index作为key可能会引发的问题:\n1。若对数据进行:逆序添加、逆序剧除等破坏顺序操作:会产生没有必要的真实DOM更新==>界面效果没问题,但效率低。\n2。如果结构中还包含输入类的DOM:会产生错误DOM更新==>界面有问题。"},"3":{"objectClass":"MindNode","ID":"411F3","lineColorHex":"#BF58F5","text":"4。开发中如何选择key?:\n1.最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值.2.如果不存在对数据的逆序添加、逆序朋除等破坏顺序操作，仅用于渲染列表用于展示，"},"objectClass":"NSArray"},"text":":key的原理和作用\n面试题:react. vue中的key有什么作用?(key的内部原理)"},"objectClass":"NSArray"},"text":"列表渲染"},"4":{"objectClass":"MindNode","ID":"Q616W","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"77CC8","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"SS285","lineColorHex":"#26BBFF","text":"push()pop()shift()unshift()splice()sort()\nreverse() Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。"},"objectClass":"NSArray"},"text":"变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组"},"1":{"objectClass":"MindNode","ID":"5M7O3","lineColorHex":"#26BBFF","text":"通过computed或者watch，根据相应的条件过滤出新的数据并显示在页面上。"},"objectClass":"NSArray"},"text":"列表过滤"},"5":{"objectClass":"MindNode","ID":"54Q42","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"8KT58","lineColorHex":"#DC306C","text":"底层使用Object.defineProperty()方法，给data对象中的属性，设置get和set 方法。中间创建一个监视的实例对象，用于监视data中的属性变化。"},"1":{"objectClass":"MindNode","ID":"D8N79","lineColorHex":"#DC306C","text":"1. vue会监测data中所有层级的数据。"},"2":{"objectClass":"MindNode","ID":"JQV54","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2D5RR","lineColorHex":"#DC306C","text":"target是data中的某一项属性，可能是对象可能是数组。"},"objectClass":"NSArray"},"text":"2. 如何监测对象中的数据？\n通过setter（也就是）实现监视，且要在new Vue时传入要监测的数据。\n（1）对象中后追加的属性，Vue默认不做响应式处理\n（2）如需给后添加的属性做响应式，要使用以下API：\nVue.set(target, propertyName/index,value)或者Vue.$set(target, propertyName/index,value)"},"3":{"objectClass":"MindNode","ID":"4NBRV","lineColorHex":"#DC306C","text":"3.如何监测数组中的数据\n通过包裹数组更新元素的方法实现：\n调用原生对应的方法对数组进行更新，然后重新解析模板更新页面。"},"4":{"objectClass":"MindNode","ID":"YK348","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"LMW6N","lineColorHex":"#DC306C","text":"Vue.set和Vue.$set不能给vm或者vm的根数据对象（data,computed,methods)添加属性。"},"objectClass":"NSArray"},"text":"4.Vue修改数组中的某个元素用如下方法：\npush()pop()shift()unshift()splice()sort()reverse() \n或者 Vue.set  Vue.$set"},"objectClass":"NSArray"},"text":"Vue监测数据的原理"},"6":{"objectClass":"MindNode","ID":"202V5","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"45RLQ","lineColorHex":"#37C45A","text":"定义：对要显示的数据进行特定格式化后再显示只适用于一些简单的逻辑"},"1":{"objectClass":"MindNode","ID":"3M7J1","lineColorHex":"#37C45A","text":"语法：\n1. 注册过滤器：Vue.filter(name,callback)或者new Vue(filters:{}) 前者是全局过滤器在子组件中也可以使用，后者是局部过滤器只能在当前组件中使用。\n2. 使用过滤器：\n{{xxx | 过滤器名}} 或者 v-bind:属性 = ‘xxx| 过滤器名’"},"2":{"objectClass":"MindNode","ID":"601PV","lineColorHex":"#37C45A","text":"过滤器也可以接收额外参数，多个过滤器 可以串联。没有改变原来的数据，产生新的对应的数据。"},"objectClass":"NSArray"},"text":"过滤器"},"7":{"objectClass":"MindNode","ID":"6WTK4","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"V8811","lineColorHex":"#1BD6E7","text":"一、定义语法:\n分为局部指令和全局指令，都有两种写法如全局指令的 Vue.directive(指令名，配置对象)或者局部注册接收一个directives选项。"},"1":{"objectClass":"MindNode","ID":"76T67","lineColorHex":"#1BD6E7","text":"配置对象中，经常使用到的三个钩子函数：\nbind 指令与元素成功绑定时调用。\ninserted 指令所在元素被插入到父元素时\nupdata 指令所在模板结构被重新解析时调用"},"objectClass":"NSArray"},"text":"自定义指令"},"8":{"objectClass":"MindNode","ID":"49B6Z","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"83FMQ","lineColorHex":"#FFC700","text":"1. 生命周期也称为生命周期钩子函数\n2. 是Vue在关键时刻给我们调用的特殊名称函数\n3. 生命周期函数名字不能更改，函数的具体内容由自己写\n4. 生命周期函数中的this指向的是vm或组件实例对象。"},"1":{"objectClass":"MindNode","ID":"VH30P","lineColorHex":"#FFC700","text":"mounted（）\nVue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted也就是说只会执行一次。"},"objectClass":"NSArray"},"text":"生命周期"},"9":{"objectClass":"MindNode","ID":"6OHY8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"DCQA3","lineColorHex":"#1BD6E7","text":"理解：用来实现局部功能效果的代码集合。"},"1":{"objectClass":"MindNode","ID":"MTMKN","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"17415","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"O4H29","lineColorHex":"#1BD6E7","text":"单文件组件，就是直接写在根组件中。"},"objectClass":"NSArray"},"text":"使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别;区别如下:\n1.el不要写，为什么?—最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。2tdata必须写成函数，为什么?——避免组件被复用时，数据存在引用关系。\n1.el不要写，为什么?—最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。2tdata必须写成函数，为什么?——避免组件被复用时，数据存在引用关系。"},"1":{"objectClass":"MindNode","ID":"3205Q","lineColorHex":"#1BD6E7","text":"二、如何注册组件?\n1.局部注册:靠new Vue的时候传入components选项\n2.全局注册:靠Vue.component(\"组件名\",组件配置选项)"},"2":{"objectClass":"MindNode","ID":"P6LQ9","lineColorHex":"#1BD6E7","text":"三、编写组件标签:\n第二步中注册的标签名直接用在模板中即可。"},"objectClass":"NSArray"},"text":"Vue中使用组件的三大步骤:\n一、定义组件(创建组件)二、注册组件三、使用组件(写组件标签)"},"2":{"objectClass":"MindNode","ID":"79I8W","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"3J1WM","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"Q1AM0","lineColorHex":"#1BD6E7","text":"(1).组件名尽可能回避HTAL中已有的元素名称，例如: h2、H2都不行。\n(2).可以使用name配置项指定组件在开发者工具中呈现的名字-"},"objectClass":"NSArray"},"text":"1. 关于组件名： 一个单词组成首字母可以大写也可以小写。多个单词组成，使用kabeb-case命名，第二种写法使用驼峰命名但是需要Vue脚手架。"},"1":{"objectClass":"MindNode","ID":"B2530","lineColorHex":"#1BD6E7","text":"2.关于组件标签:\n第一种写法:<school></school>第二种写法:<school/>\n\n备注:不用使用脚手架时，<school/>会导致后续组件不能渲染。"},"2":{"objectClass":"MindNode","ID":"SO6M5","lineColorHex":"#1BD6E7","text":"3. 一个简写方式:\nconst school = Vue.extend(options）可简写为: const school = options对象"},"3":{"objectClass":"MindNode","ID":"456P2","lineColorHex":"#1BD6E7","text":"4. 单个根元素\n构建一个组建的时候，在模板中必须用一个根元素包裹模板里的内容。"},"objectClass":"NSArray"},"text":"组件的几个注意点"},"3":{"objectClass":"MindNode","ID":"J6M8K","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"KF286","lineColorHex":"#1BD6E7","text":"1.创建的组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。当在父组件注册成标签并且在父组件的模板中使用时，就会生成VueComponent 实例对象。"},"1":{"objectClass":"MindNode","ID":"38YB2","lineColorHex":"#1BD6E7","text":"2,我们只需要写<school/>或<school</school>，Vue解析时会帮我们创建school组件的实例对象,vue帮我们执行的:new VueComponent(options)."},"2":{"objectClass":"MindNode","ID":"F8UIM","lineColorHex":"#1BD6E7","text":"3.特别注意:每次调用vue.extend，返回的都是一个全新的VueComponent! ! ! !"},"3":{"objectClass":"MindNode","ID":"24MSX","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"G4G7P","lineColorHex":"#1BD6E7","text":"(1).组件配置中:\ndata函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【VueComponent实例对象】"},"1":{"objectClass":"MindNode","ID":"4KI82","lineColorHex":"#1BD6E7","text":"(2).new Vue(options)配置中:\ndata函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【Vue实例对象】。"},"objectClass":"NSArray"},"text":"4.关于this指向:"},"4":{"objectClass":"MindNode","ID":"7RHU3","lineColorHex":"#1BD6E7","text":"vm实例身上有一个$children属性，是一个包含子组件实例的数组。"},"5":{"objectClass":"MindNode","ID":"18387","lineColorHex":"#1BD6E7","text":"一个很重要的内置关系：\nVuecompoonet.prototype.__proto__ === Vue.prototype!!!\n组件实例可以访问到Vue原型上的属性和方法。"},"objectClass":"NSArray"},"text":"VueComponent构造函数"},"4":{"objectClass":"MindNode","ID":"X2DL6","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"7J420","lineColorHex":"#1BD6E7","text":"1.vue.js 'vue.runtime.xxx.js的区别:\n(1).vue.js是完整版的Vue，包含:核心功能+模板解析器。\n(2). vue.runtime.xxx,js是运行版的Vue，只包含:核心功能;没有模板解析器。"},"1":{"objectClass":"MindNode","ID":"6X3UQ","lineColorHex":"#1BD6E7","text":"render函数：\nvue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。通常就是App。"},"2":{"objectClass":"MindNode","ID":"P42E5","lineColorHex":"#1BD6E7","text":"修改默认配置：\n要在vue.config.js中修改，相关Api都是设计好的。"},"3":{"objectClass":"MindNode","ID":"K6C41","lineColorHex":"#1BD6E7","text":"ref属性：\n1.被用来给元素或子组件注册引用信息（id的替代者)\n2.应用在htm1标签上获取的是真实DOM元素，应用在组件标签上获取的是是组件实例对象(vc)\n3.使用方式:\n  打标识:<h1 ref=\"xxx\">.....</h1>或<School ref=\"xoxx\"></Schobl>获取: this.$refs.xxx"},"objectClass":"NSArray"},"text":"单文件组件以及vue脚手架"},"5":{"objectClass":"MindNode","ID":"N7J7J","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"8KOC6","lineColorHex":"#1BD6E7","text":"混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。"},"1":{"objectClass":"MindNode","ID":"C2132","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"I897F","lineColorHex":"#1BD6E7","text":"同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。"},"objectClass":"NSArray"},"text":"选项合并：当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。并在发生冲突时以组件数据优先。"},"2":{"objectClass":"MindNode","ID":"46YB8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"672D3","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"138IT","lineColorHex":"#1BD6E7","text":"一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。"},"objectClass":"NSArray"},"text":"第二步使用混入，例如:\n(1).全局混入:Vue.mixin(xxx)\n(2).局部混入:mixins : [ \"xxx ']"},"objectClass":"NSArray"},"text":"第一步定义混合，例如:\nconst mixin =  {\n    data(){..}.\n     methods:{....]\n}"},"objectClass":"NSArray"},"text":"混入 mixin"},"6":{"objectClass":"MindNode","ID":"Q29F2","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"0554E","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"M10KX","lineColorHex":"#1BD6E7","text":"功能是让组件接收外部传过来的数据"},"1":{"objectClass":"MindNode","ID":"1UCH1","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"513IW","lineColorHex":"#1BD6E7","text":"如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)"},"objectClass":"NSArray"},"text":"（1）传递数据\n<Demo name='xxx'>传递的是一个普通键值对，因为不是绑定属性。<Demo :name='xxx'> 通过计算分号内的JS表达式传值。\n如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)"},"2":{"objectClass":"MindNode","ID":"4I8EJ","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"S9TWM","lineColorHex":"#1BD6E7","text":"如果不加v-bind则传递的是一个字符串，加上v-bind之后就是一个JS表达式，就可以传递正确的数字类型。"},"objectClass":"NSArray"},"text":"(2)接收数据：\n第一种方式（只接收）:props: [ 'name ']\n第二种方式（限制类型):props:{name:string}\n第三种方式(限制类型、限制必要性、指定默认值):props:{\nname:{\n      type:String,1/类型\n      required:true,1/必要性\n       default:\"老王’1/默认值}\n}"},"3":{"objectClass":"MindNode","ID":"JN856","lineColorHex":"#1BD6E7","text":"备注: props是只读的。Vue底层会监测你对props的修改。如果进行了修改。就会发出警告，若业务需求确实需要修改。那么请复制props的内容到data中一份，然后去修改data中的数据。"},"objectClass":"NSArray"},"text":"props"},"1":{"objectClass":"MindNode","ID":"V42O7","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"R144V","lineColorHex":"#1BD6E7","text":"自定义事件名一定要用短斜杠命名法！！！！"},"1":{"objectClass":"MindNode","ID":"6KUD1","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"14DGD","lineColorHex":"#1BD6E7","text":"第一种写法，比如在App跟组件上，映射了一个组件<Student> 可以通过给它用@或者v-on:自定义事件名=“事件函数”绑定一个自己命名的事件，事件的回调函数在父组件中，子组件触发。\n\n然后在子组件Student中，通过某个原生的事件函数比如点击事件@click=“xxxxx”，在xxxx这个函数中去使用this.$emit('aaa')触发自定义事件函数，注意自定义事件名一定不能写错。"},"1":{"objectClass":"MindNode","ID":"J8EMH","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"5J6L4","lineColorHex":"#1BD6E7","text":"在子组件上<Student ref=\"student\">，这样在根组件App上就可以用this.$refs.student就可以拿到子组件的实例对象。\n\n通过$on侦听自定义事件$on(eventName, eventHandler)\nthis.$refs.student.$on('自定义事件名',this.事件的回调函数)"},"objectClass":"NSArray"},"text":"第二种写法 \n使用ref，ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。"},"objectClass":"NSArray"},"text":"自定义事件是绑定在一个组件标签上的，用来通过父组件给子组件绑定一个自定义事件实现子组件给父组件传递数据。触发事件是在子组件中完成的。"},"2":{"objectClass":"MindNode","ID":"W0O57","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"32DT6","lineColorHex":"#1BD6E7","text":"通过 $off(eventName, eventHandler) 停止侦听一个事件。\n如果想解绑多个自定义事件，需要传递一个数组，数组中存放的是自定义事件名字符串。"},"objectClass":"NSArray"},"text":"给一个子组件解绑自定义事件\n与触发自定义事件一样，解绑自定义事件也是在子组件中完成。"},"3":{"objectClass":"MindNode","ID":"X574O","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"EM3G8","lineColorHex":"#1BD6E7","text":"通过 $on(eventName, eventHandler) 侦听一个事件\n通过 $once(eventName, eventHandler) 一次性侦听一个事件\n通过 $off(eventName, eventHandler) 停止侦听一个事件"},"objectClass":"NSArray"},"text":"给子组件绑定原生事件\n使用.native修饰符即可"},"objectClass":"NSArray"},"text":"自定义事件"},"2":{"objectClass":"MindNode","ID":"S761K","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"277D4","lineColorHex":"#1BD6E7","text":""},"1":{"objectClass":"MindNode","ID":"NO50F","lineColorHex":"#1BD6E7","text":""},"objectClass":"NSArray"},"text":"全局事件总线\n任意组件间通信"},"3":{"objectClass":"MindNode","ID":"QJ61G","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"4U8OO","lineColorHex":"#1BD6E7","text":""},"1":{"objectClass":"MindNode","ID":"7832Y","lineColorHex":"#1BD6E7","text":""},"objectClass":"NSArray"},"text":"消息订阅与发布\n任意组件间通信"},"objectClass":"NSArray"},"text":"组件间通信"},"7":{"objectClass":"MindNode","ID":"T41GC","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"53812","lineColorHex":"#1BD6E7","text":"通过 Vue 的 <component> 元素加一个特殊的 is attribute 来实现。<keep-alive>元素将动态组件包裹起来就可以了。"},"objectClass":"NSArray"},"text":"动态组件和异步组件"},"objectClass":"NSArray"},"text":"组件"},"10":{"objectClass":"MindNode","ID":"0STDM","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"1G3IY","lineColorHex":"#1BD6E7","text":"作用原理：在插入、更新或移除DOM元素时，再合适的时候给元素添加样式类名。"},"1":{"objectClass":"MindNode","ID":"3ICG8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"8M208","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"R3WOP","lineColorHex":"#1BD6E7","text":".hello-enter-active{\nanimation: atguigu 0.5s linear;\n}\n\n.hello-leave-active{\nanimation: atguigu 8.5s linear reverse;\n}\n\n@keyframes atguigu {\n       from{\n          transform: translatex(-100%);\n        to{\n           }\n}"},"objectClass":"NSArray"},"text":"有两种写法，第一种是使用css3动画规则，@keyframs定义动画实现的规则，再在v-enter-acitve或者v-leave-active中使用animate规定动画执行时间等等"},"1":{"objectClass":"MindNode","ID":"YJ79M","lineColorHex":"#1BD6E7","text":"第二种写法，就是使用完整的进入离开书写。"},"objectClass":"NSArray"},"text":"Enter 进入：v-Enter 进入的起点，v-Enter-to进入的终点，v-enter-active进入的过程。\nleave 离开 与上一样。"},"objectClass":"NSArray"},"text":"过渡与动画"},"11":{"objectClass":"MindNode","ID":"61SDS","lineColorHex":"#FFC700","text":"vue-resource\n插件库，"},"12":{"objectClass":"MindNode","ID":"N35GG","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"LYI04","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"HE2TI","lineColorHex":"#DC306C","text":"在子组件标签中如果使用了子组件中定义的变量，则会是undefined。因为这个变量是定义在父组件中传给子组件的，不是在子组件中定义的。"},"1":{"objectClass":"MindNode","ID":"2G4BM","lineColorHex":"#DC306C","text":"后备内容\n如果子组件中设置了slot，但是父组件没有传，则可以在子组件的slot标签中写一些内容。"},"objectClass":"NSArray"},"text":"在组件中template里，定义一个<slot>标签，等待组件的使用者即父组件进行填充，填充的内容就是在父组件的template中使用子组件标签时，在子组件标签里写的元素。让父组件可以向子组件指定位置插入HTML结构，也是一种组件间通信得方式，父传子。"},"1":{"objectClass":"MindNode","ID":"W76SF","lineColorHex":"#DC306C","text":"默认插槽"},"2":{"objectClass":"MindNode","ID":"S6E5U","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5454Q","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"YPVYU","lineColorHex":"#DC306C","text":" <template v-slot:header>\n    <h1>Here might be apagetitle</h1>\n  </template>"},"1":{"objectClass":"MindNode","ID":"W3W6Z","lineColorHex":"#DC306C","text":"注意 v-slot 只能添加在 <template> 上 (只有一种例外情况)"},"objectClass":"NSArray"},"text":"slot插槽的一个属性 name，可以用来定义额外的插槽。\n在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称"},"objectClass":"NSArray"},"text":"具名插槽"},"3":{"objectClass":"MindNode","ID":"B616S","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2GUPL","lineColorHex":"#DC306C","text":"父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。"},"1":{"objectClass":"MindNode","ID":"KTVEG","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"8D2A5","lineColorHex":"#DC306C","text":"<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>"},"1":{"objectClass":"MindNode","ID":"6VSV2","lineColorHex":"#DC306C","text":"<current-user>\n  {{ user.firstName }}\n</current-user>\n父组件中的"},"objectClass":"NSArray"},"text":"如果在插槽内容中使用了子组件的变量，但是提供的插槽内容是在父级渲染的，所以如果想让子组件变量在父组件中使用，可以将这个变量作为<slot>元素的一个属性绑定上去。"},"2":{"objectClass":"MindNode","ID":"V62UF","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"C0MZQ","lineColorHex":"#DC306C","text":"子组件传递来的变量对象，将作为父组件v-slot定义的插槽prop的属性。"},"objectClass":"NSArray"},"text":"绑定在 <slot> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字。"},"3":{"objectClass":"MindNode","ID":"3S05I","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"437ZE","lineColorHex":"#DC306C","text":"<current-user v-slot:default=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>"},"objectClass":"NSArray"},"text":"当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot 直接用在组件上"},"objectClass":"NSArray"},"text":"作用域插槽"},"objectClass":"NSArray"},"text":"slot插槽"},"13":{"objectClass":"MindNode","ID":"E2205","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1325K","lineColorHex":"#BF58F5","text":"1. 访问根实例\n在子组件中，可以通过$root来访问根实例，以获取其中的数据。"},"1":{"objectClass":"MindNode","ID":"424S3","lineColorHex":"#BF58F5","text":"2. 访问父级组件实例\n$parent 用来从子组件访问父组件的实例。以替代将数据以 prop 的方式传入子组件的方式。"},"2":{"objectClass":"MindNode","ID":"32F31","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"271LY","lineColorHex":"#BF58F5","text":"当 ref 和 v-for 一起使用的时候，你得到的 ref 将会是一个包含了对应数据源的这些子组件的数组。"},"objectClass":"NSArray"},"text":"3. 访问子组件和子元素\n尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用。"},"3":{"objectClass":"MindNode","ID":"6D92O","lineColorHex":"#BF58F5","text":"4.程序化的事件侦听器\n通过 $on(eventName, eventHandler) 侦听一个事件\n通过 $once(eventName, eventHandler) 一次性侦听一个事件\n通过 $off(eventName, eventHandler) 停止侦听一个事件"},"4":{"objectClass":"MindNode","ID":"9O76M","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"WL218","lineColorHex":"#BF58F5","text":"name: 'stack-overflow',\ntemplate: '<div><stack-overflow></stack-overflow></div>'"},"objectClass":"NSArray"},"text":"5.递归组件\n当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。"},"objectClass":"NSArray"},"text":"处理边界情况"},"objectClass":"NSArray"},"text":"vue"},"ID":"416IE","style":100}