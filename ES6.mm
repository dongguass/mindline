{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"4MNN5","rootPoint":{"objectClass":"CGPoint","x":360,"y":7545},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"G45YH","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"77FEE","lineColorHex":"#DC306C","text":"var声明以及变量提升：\nES5语法只有两种作用域，函数作用域和全局作用域，无论在哪声明都会被当成在当前作用域的顶部声明的变量。"},"1":{"objectClass":"MindNode","ID":"XVHMX","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2TTJB","lineColorHex":"#DC306C","text":"let声明：\nlet声明不会被提升（但是会存在一个问题临时死区），因此通常将let声明放在封闭代码块的顶部。","summaries":{"0":{"objectClass":"NodeSummary","ID":"L1462","text":"假设作用域中已经存在某个标识符，此时再使用let或者const关键字声明它就会抛出错误，也就是不允许重复声明","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"1":{"objectClass":"MindNode","ID":"L1462","lineColorHex":"#DC306C","text":"const声明：\nconst声明的是常量，值一旦确定之后不可更改，所以通过const声明的常量必须进行初始化。\n用const声明对象：\nconst声明不允许修改绑定，但允许修改值。这也就意味着用const声明对象后，可以修改该对象的属性值"},"2":{"objectClass":"MindNode","ID":"GTUC1","lineColorHex":"#DC306C","text":"临时死区：\n也就是作用域到let或者const声明之前这段区域，如果在这段区域使用到声明的变量会报错。但是在let或者const作用域外使用变量则不会报错，但可能得到undefined或者null。"},"objectClass":"NSArray"},"text":"块级声明：\nES6语法中，块级作用域存在于：函数内部，块中（字符{ }之间的区域）。let和const声明的都是块级标识符，所以一旦执行到块外就会立即被销毁。"},"2":{"objectClass":"MindNode","ID":"1JCU7","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"671J1","lineColorHex":"#DC306C","text":"简要阐述：\n一个循环for(var i=0;i<n=i++)使用var声明的i因为存在声明提升，在循环结束后仍然可以访问，但是使用let声明的就可以解决这个问题。"},"1":{"objectClass":"MindNode","ID":"4S88A","lineColorHex":"#DC306C","text":"循环中的函数：\n 因为var声明，循环里的每次迭代同时共享着变量i，循环内部创建的函数全都保留了对相对变量的引用。let声明使每次迭代循环都会创建一个新变量，并以之前迭代同名变量的值初始化。"},"objectClass":"NSArray"},"text":"循环中的块作用域绑定"},"3":{"objectClass":"MindNode","ID":"9HQA6","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"JDLCC","lineColorHex":"#DC306C","text":"如果你在全局作用域中使用let或const，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。换句话说，用let或const不能覆盖全局变量，而只能遮蔽它。"},"objectClass":"NSArray"},"text":"全局作用域绑定"},"4":{"objectClass":"MindNode","ID":"2373M","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"CRQ10","lineColorHex":"#DC306C","text":"let与const这一新特性还存在一个副作用，即不能在声明变量前访问它们，就算用typeof这样安全的操作符也不行。在声明前访问块级绑定会导致错误，因为绑定还在临时死区（TDZ）中。\n\n当前使用块级绑定的最佳实践是：默认使用const，只在确实需要改变变量的值时使用let。这样就可以在某种程度上实现代码的不可变，从而防止某些错误的产生。"},"objectClass":"NSArray"},"text":"小结"},"objectClass":"NSArray"},"text":"块级作用域绑定"},"1":{"objectClass":"MindNode","ID":"3YOF0","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2S3X5","lineColorHex":"#BF58F5","text":"更好的Unicode支持（了解即可）"},"1":{"objectClass":"MindNode","ID":"GH8B8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5JN3T","lineColorHex":"#BF58F5","text":"JS中，正则表达式通常用于两个字符串方法：search（）和replace（）。\nsearch（） 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回字符串的起始位置。\n\nreplace（） 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。"},"1":{"objectClass":"MindNode","ID":"E428G","lineColorHex":"#BF58F5","text":"正则表达式修饰符：\n1. i 执行对大小写不敏感的匹配\n2. g 执行全局匹配（查找所有匹配而非在找到第一个匹配之后就停下）\n3. m 执行多行匹配"},"2":{"objectClass":"MindNode","ID":"089L5","lineColorHex":"#BF58F5","text":"正则表达式模式：\n1. [abc] 查找方括号之间的任何字符\n2. [0-9] 查找任何从0到9的数字\n3. （x|y）查找任何以| 分隔的选项\n\n元字符：\n1. \\d 查找数字\n2. \\s 查找空白字符\n3. \\b 匹配单词边界\n4. \\uxxxx 查找以十六进制数 xxxx规定的unicode字符\n\n量词：\n1. n+ 匹配任何包含至少一个n的字符串\n2. n* 匹配任何包含零个或多个n的字符串\n3. n？匹配任何包含0个或一个的字符串\n"},"objectClass":"NSArray"},"text":"正则表达式：\n正则表达式是由一个字符序列形成的搜索模式。\n语法：/pattern/modifiers \n比如: var patt = /w3cschool/i w3cschool是一个模式（用于检索） i使修饰符（搜索不区分大小写）"},"2":{"objectClass":"MindNode","ID":"7DG67","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"U5KN4","lineColorHex":"#BF58F5","text":""},"objectClass":"NSArray"},"text":"其他正则表达式语法变更"},"3":{"objectClass":"MindNode","ID":"UH2O7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"Z32NM","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"HZ683","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"T9D5K","lineColorHex":"#BF58F5","text":"注意：\n对于startsWith()、endsWith()及includes()这3个方法，如果你没有按照要求传入一个字符串，而是传入一个正则表达式，则会触发一个错误产生；而对于indexOf()和lastIndexOf()这两个方法，它们都会把传入的正则表达式转化为一个字符串并搜索它。"},"objectClass":"NSArray"},"text":"这三个方法都接受两个参数：第一个参数指定要搜索的文本，第二参数指定开始搜索的位置。endsWith（）方法指定了第二参数的话，就会从字符串长度减去这个索引值的位置开始搜索。"},"objectClass":"NSArray"},"text":"新增三个方法用来检测子字符串：\n· includes()方法，如果在字符串中检测到指定文本则返回true，否则返回false。·startsWith()方法，如果在字符串的起始部分（从字符串开头）检测到指定文本则返回true，否则返回false。· endsWith()方法，如果在字符串的结束部分（从字符串末尾）检测到指定文本则返回true，否则返回false。"},"1":{"objectClass":"MindNode","ID":"400Y8","lineColorHex":"#BF58F5","text":"repeat（）方法：\n接受一个number类型的参数，表示该字符串重复的次数，返回值是当前字符串重复一定次数后的新字符串。\n\n可以用这个方法实现公式化工具中创建缩进级别：\nlet indext = \" \".repeat(4)"},"objectClass":"NSArray"},"text":"其他字符串变更"},"4":{"objectClass":"MindNode","ID":"95612","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"755BO","lineColorHex":"#BF58F5","text":"基础语法：\n模板字面量最简单的用法，看起来好像只是用反撇号（`）替换了单、双引号。"},"1":{"objectClass":"MindNode","ID":"47744","lineColorHex":"#BF58F5","text":"字符串占位符：\n可以把任何合法的JavaScript表达式嵌入到占位符中并将其作为字符串的一部分输出到结果中。语法：${表达式}。\n并且可以在模板字面量里嵌套另一个。"},"2":{"objectClass":"MindNode","ID":"13197","lineColorHex":"#BF58F5","text":"通过模板标签可以访问到字符转义被转换成等价字符前的原生字符串。最简单的例子是使用内建的String.raw()标签。"},"objectClass":"NSArray"},"text":"模板字面量\n多行字符串　一个正式的多行字符串的概念。基本的字符串格式化　将变量的值嵌入字符串的能力。\nHTML转义　向HTML插入经过安全转换后的字符串的能力。","style2":{"objectClass":"NSDictionary","color":"#E2E1E1"}},"objectClass":"NSArray"},"text":"字符串和正则表达式"},"2":{"objectClass":"MindNode","ID":"U6J76","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"V4PHL","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"5HGXI","lineColorHex":"#26BBFF","text":"默认参数表达式：\n可以给形参赋一个函数调用来获得默认参数。切记函数调用作为默认参数不能忘记小括号，如果是这样 形参=函数名 则始终传入的是对函数的引用。\n\n因为上面的特性，可以使用先定义的参数作为后定义的参数的默认值。形参赋值默认值也存在临时死区所以不能用后定义的参数赋前面的值。"},"1":{"objectClass":"MindNode","ID":"MHQQR","lineColorHex":"#26BBFF","text":"在非严格模式下，命名参数的变化会同步更新到arguments对象中。在ECMAScript 5的严格模式下，取消了arguments对象的这个令人感到困惑的行为，无论参数如何变化，arguments对象不再随之改变。"},"objectClass":"NSArray"},"text":"函数形参的默认值：\n声明函数时，可以为任意参数指定默认值。如果一个函数使用了默认参数值，则无论是否显式定义了严格模式，arguments对象的行为都将与ECMAScript 5严格模式下保持一致，即无论参数如何变化，arguments对象不随之改变，arguments的length值就会是你传入的实参的个数。"},"1":{"objectClass":"MindNode","ID":"35K0W","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"5U2BE","lineColorHex":"#26BBFF","text":" 在函数的命名参数前加三个... 就表明这是一个不定参数，该参数为一个数组！包含着自它之后传入的所有参数。但是会影响length属性值，不会被计算。\n不定参数有两条使用限制。首先，每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾。","summaries":{"0":{"objectClass":"NodeSummary","ID":"DLX2E","text":"不定参数是将独立的参数整合成数组传入，而展开运算符是将数组拆开使其中的元素单独传入","color":"#32CD32","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"objectClass":"NSArray"},"text":"无名参数：\n通过引入不定参数（restparameters）的特性可以解决这些问题。无论是否使用不定参数，arguments对象总是包含所有传入函数的参数。"},"2":{"objectClass":"MindNode","ID":"DLX2E","lineColorHex":"#26BBFF","text":"展开运算符\n与不定参数很相似。展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数。如下：\nlet value = [25,35,45,65];\nconsole.log(Math.max(...value));\n并且还可以传入其他值。"},"3":{"objectClass":"MindNode","ID":"Y4NNR","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"9303I","lineColorHex":"#26BBFF","text":"1. 当使用函数声明式声明的函数赋值给一个变量，这个函数的name属性值是函数名。\n\n2. 对象中的方法的name属性就是方法名，对于get set方法person.firstName实际上是一个getter函数，所以它的名称为\"get firstName\"，setter函数的名称中当然也有前缀\"set\"。"},"1":{"objectClass":"MindNode","ID":"1A952","lineColorHex":"#26BBFF","text":"还有另外两个有关函数名称的特例：通过bind()函数创建的函数，其名称将带有\"bound\"前缀；通过Function构造函数创建的函数，其名称将带有前缀\"anonymous\""},"objectClass":"NSArray"},"text":"name属性：\n函数声明式声明的函数，name属性就是函数名。对于使用函数表达式，匿名函数的name属性的值就是引入这个函数的变量名。"},"4":{"objectClass":"MindNode","ID":"XJ4EI","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"LL811","lineColorHex":"#26BBFF","text":"1.当通过new关键字调用函数时，执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后再执行函数体，将this绑定到实例上。"},"1":{"objectClass":"MindNode","ID":"XYO1T","lineColorHex":"#26BBFF","text":"2. 如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体"},"2":{"objectClass":"MindNode","ID":"K048F","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"673G2","lineColorHex":"#26BBFF","text":"元属性指非对象属性，可以提供非对象目标的补充信息。当调用函数的[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数。所以可以通过检测new.target判断是不是new调用。"},"objectClass":"NSArray"},"text":"为了解决函数是否通过new关键字调用的问题，ES6引入了new.target元属性。"},"objectClass":"NSArray"},"text":"明确函数的多重用途：\nJS函数有两个不同的内部方法：call 和construct。具有construct方法的函数被称为构造函数。","markType":7},"5":{"objectClass":"MindNode","ID":"8FG02","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"1DVGY","lineColorHex":"#26BBFF","text":"在代码块中声明一个块级函数严格来说是一个语法错误，但是所有的浏览器仍然支持这个特性。最好的选择是使用函数表达式，而不是函数声明式。"},"1":{"objectClass":"MindNode","ID":"W1TR4","lineColorHex":"#26BBFF","text":"ES6中严格模式下，会将代码块内的函数作为一个块级声明，从而可以在定义该函数的代码块内访问和调用它。在定义函数的代码块内，块级函数会被提升至顶部。"},"2":{"objectClass":"MindNode","ID":"QOLEP","lineColorHex":"#26BBFF","text":"使用场景：\n"},"objectClass":"NSArray"},"text":"块级函数\n严格模式下：在定义函数的代码块内，块级函数会被提升至顶部。\n非严格模式下：在这个示例中，doSomething()函数被提升至全局作用域\nif(true){\n    console.log(typeof dosomthing);\n    function dosomthing(){\n        console.log(1)\n    }\n\n    dosomthing();\n}\n\nconsole.log(typeof dosomthing);\nconsole.log(2);"},"6":{"objectClass":"MindNode","ID":"UJWQU","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"6DBS8","lineColorHex":"#26BBFF","text":"与传统Js函数的不同点：\n1.  没有this、super、arguments和new.target绑定　箭头函数中的this、super、arguments及new.target这些值由外围最近一层非箭头函数决定。\n2. 不能通过new关键字调用\n3. 没有原型\n4. 不可以改变this的绑定 函数内部的this值不可被改变，在函数的生命周期内始终保持一致\n5. 不支持arguments对象\n6.不支持重复的命名参数"},"1":{"objectClass":"MindNode","ID":"NGUD7","lineColorHex":"#26BBFF","text":"语法：\n所有变种都由函数参数、箭头、函数体组成，根据使用的需求，参数和函数体可以分别采取多种不同的形式。\n\n1. 当只有一个参数时，可以直接写参数名箭头紧随其后，箭头右侧的表达式被求值后便立即返回。\n2. 传入两个或两个以上需要加小括号。没有参数的话就写一组没有内容的小括号。\n3. 如果想返回一个对象字面量，则需要将字面量包裹在小括号里。"},"objectClass":"NSArray"},"text":"箭头函数"},"7":{"objectClass":"MindNode","ID":"5N3P7","lineColorHex":"#26BBFF","text":"尾调用优化\n尾调用指的是函数作为另一个函数的最后一条语句被调用。比如：\nfunction A(){\n return  B()\n}"},"objectClass":"NSArray"},"text":"函数"},"3":{"objectClass":"MindNode","ID":"OFSX2","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"CP6EP","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"Z7PF1","lineColorHex":"#37C45A","text":"首先，在模块的顶部，this的值是undefined；其次，模块不支持HTML风格的代码注释，这是从早期浏览器残余下来的JavaScript特性。\n\n脚本，也就是任何不是模块的JavaScript代码，则缺少这些特性。"},"objectClass":"NSArray"},"text":"什么是模块：\n模块是自动运行在严格模式下并且没有办法退出运行的JS代码。"},"1":{"objectClass":"MindNode","ID":"123LJ","lineColorHex":"#37C45A","text":"导出的基本语法：\n以将export放在任何变量、函数或类声明的前面，以将它们从模块导出。如\nexport let name = \"Jack\"\nexport function sum(a,b){}\n对于函数，定义时不必总是导出声明，可以在之后使用export {变量名、函数名}这种形式导出。"},"2":{"objectClass":"MindNode","ID":"RV758","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"CH778","lineColorHex":"#37C45A","text":"模块语法的限制：\n因为import、export是在编译阶段执行的，属于静态执行的，所以不能使用表达式和变量作为导入地址。并且它们都不能出现在if语句中和函数中。"},"1":{"objectClass":"MindNode","ID":"1CH2P","lineColorHex":"#37C45A","text":"导入时，浏览器使用的路径格式与传给<script>元素的相同，也就是说，必须把文件扩展名也加上。另一方面，Node.js则遵循基于文件系统前缀区分本地文件和包的惯例。例如，example是一个包而./example.js是一个本地文件。"},"2":{"objectClass":"MindNode","ID":"2840D","lineColorHex":"#37C45A","text":"当从一个模块中导入一个绑定时，就无法定义另一个同名变量，也无法在import语句前使用标识符或改变绑定的值。"},"3":{"objectClass":"MindNode","ID":"DDK10","lineColorHex":"#37C45A","text":"导入单个绑定\n就算一个模块导出了很多函数，也可以只导入一个函数，并且不能给它重新赋值。为了最好的兼容多个浏览器和Node.js环境，一定要在字符串之前包含/ ./ ../。"},"4":{"objectClass":"MindNode","ID":"64322","lineColorHex":"#37C45A","text":"从example.js中导出的所有绑定被加载到一个被称作example的对象中。指定的导出（sum()函数、mutiply()函数和magicNumber）之后会作为example的属性被访问。这种导入格式被称作命名空间导入（namespace import）。"},"5":{"objectClass":"MindNode","ID":"M18FQ","lineColorHex":"#37C45A","text":"导入绑定的一个微妙之处：\n标识符只有在被导出的模块中可以修改，即便是导入绑定的模块也无法更改绑定的值。"},"objectClass":"NSArray"},"text":"导入的基本语法：\nimport 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（ profile.js ）对外接口的名称相同。如果想重新取名字要使用as关键字。import命名输入的变量都是只读的，不能修改接口。\n\n* 变量名 实现整体加载：\n除了指定加载某个输出值，还可以使用整体加载，即用星号（ * ）指定一个对象，所有输出值都加载在这个对象上面。"},"3":{"objectClass":"MindNode","ID":"83ARL","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"5K57L","lineColorHex":"#37C45A","text":"导出默认值：\n1. 定义时导出export default function() \n可以导出匿名函数\n2. export default 变量名\n3. export {变量名 as default}"},"1":{"objectClass":"MindNode","ID":"8ILN6","lineColorHex":"#37C45A","text":"导入默认值：\n接受导出的默认值时，可以不适用大括号，并且可以指定任意名字。\nimport customName from './export-default';\n\n对于导出默认值和一个或多个非默认绑定的模块时，可以使用一条语句导入：\nimport 默认导出，{非默认导出} from “”\n用逗号将默认的本地名称与大括号包裹的非默认值分隔开，请记住，在import语句中，默认值必须排在非默认值之前。"},"objectClass":"NSArray"},"text":"模块默认值 export default：\n注意只能为每个模块设置一个默认的导出值，导出时多次使用default关键字是一个语法错误。"},"4":{"objectClass":"MindNode","ID":"0UO60","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"Q69VU","lineColorHex":"#37C45A","text":"export { foo, bar } from 'my_module';\n\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };"},"objectClass":"NSArray"},"text":"export和import混合使用：\n如果在一个模块中，先引入了另一个模块导出的函数或者变量，现在想把引入的导出给第三个模块，这时可以使用这种写法："},"5":{"objectClass":"MindNode","ID":"FFYK7","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"E82KM","lineColorHex":"#37C45A","text":"A从B导入了一个模块，现在要把A导出到C，在A模块中就可以不用写impot，只用写一个export {xxx} from ' ./B.js'。这种形式的export在指定的模块中查找sum声明，然后将其导出。"},"objectClass":"NSArray"},"text":"重新导出一个绑定"},"6":{"objectClass":"MindNode","ID":"RX6O4","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"12E6X","lineColorHex":"#37C45A","text":"具体查看书籍"},"objectClass":"NSArray"},"text":"加载模块"},"objectClass":"NSArray"},"text":"模块封装代码"},"4":{"objectClass":"MindNode","ID":"5X5TX","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"8INX1","lineColorHex":"#1BD6E7","text":"对象类别：\n1. 普通对象，具有JS对象所有的默认内部行为。\n2. 特异对象，具有某些与默认行为不符的内部行为。\n3. 标准对象，ES6规范中定义的对象。\n4. 内建对象，脚本执行时存在于JS执行环境中的对象，所有标准对象都是内建对象。"},"1":{"objectClass":"MindNode","ID":"2Q7R7","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"65439","lineColorHex":"#1BD6E7","text":"1. 属性初始值的简写：\n当一个对象的属性和本地变量名相同时，不必再写冒号和值，简单的致谢属性名即可。当对象字面量只有一个属性名称时，JS引擎会在可访问作用域中查找同名变量，则该变量的值会赋值给对象字面量里的同名属性。所以多用在为对象字面量的属性赋同名局部变量的值是一种常见的做法。"},"1":{"objectClass":"MindNode","ID":"5SF78","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"P1V12","lineColorHex":"#1BD6E7","text":"let a = {\n    name,\n    age,\n    sayName(){\n        console.log(this.name);\n    }\n}"},"objectClass":"NSArray"},"text":"2. 对象方法的简写语法：\nES6中，定义方法消除了冒号和function关键字，如右所示。简写方法与ES5写法最大的区别在于简写方法可以使用super关键字。还有一个name属性，值为小括号前的名字。"},"2":{"objectClass":"MindNode","ID":"12545","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"C1X81","lineColorHex":"#1BD6E7","text":"在ES6中，可以在对象字面量中使用可计算属性名称，语法与前面的相同。"},"objectClass":"NSArray"},"text":"3. 可计算属性名：\nES5中，如果想要通过计算得到属性名，要使用方括号代替点记法，以及一些特殊的属性名比如属性名中包含空格，都需要使用中括号。"},"objectClass":"NSArray"},"text":"对象字面量语法扩展"},"2":{"objectClass":"MindNode","ID":"20CVN","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"P674S","lineColorHex":"#1BD6E7","text":"1. Object.is()方法\n接受两个参数，如果两个参数类型相同且具有相同的值，则返回true。"},"1":{"objectClass":"MindNode","ID":"BSE61","lineColorHex":"#1BD6E7","text":"2. Object.assign()方法\n","markType":7},"objectClass":"NSArray"},"text":"新增方法"},"3":{"objectClass":"MindNode","ID":"TI4QT","lineColorHex":"#1BD6E7","text":"重复的对象字面量属性：\nES5严格模式下，对象字面量有重名属性会报错。在ES6中，这个重复属性检查被移除了，无论什么模式下，对于每一组重复属性都会选取最后一个取值。"},"4":{"objectClass":"MindNode","ID":"BNQN1","lineColorHex":"#1BD6E7","text":"自有属性枚举顺序：\n自有属性枚举顺序规则是：所有数字键按升序排序，所有字符串键按加入对象的顺序排序。字符串键紧随数值键。 使用Object.getOwnPropertyNames()方法处理属性。","markType":7},"5":{"objectClass":"MindNode","ID":"V315G","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"083SQ","lineColorHex":"#1BD6E7","text":"ES6添加了，Object.setPrototypeOf()方法，它接受两个参数：被改变原型的对象及替代第一个参数原型的对象。"},"1":{"objectClass":"MindNode","ID":"9I15M","lineColorHex":"#1BD6E7","text":"简化原型访问的super引用：\nsuper相当于Object.getprototypeOf(this)，就可以直接获取到实例对象的原型。必须要在简写方法的对象中使用super引用"},"objectClass":"NSArray"},"text":"增强对象原型：\n原型是JS继承的基础，原型在对象被创建时指定并在对象实例化之后保持不变，缺少对象在实例化后改变原型的标准方法。","markType":7},"6":{"objectClass":"MindNode","ID":"891O8","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"44HAP","lineColorHex":"#1BD6E7","text":"ES6中方法定义为一个函数，它会有一个内部的[[HomeObject]]属性来容纳这个方法的从属对象，Super引用都通过这个属性来确定后续的运行。"},"objectClass":"NSArray"},"text":"正式的方法定义"},"objectClass":"NSArray"},"text":"扩展对象的功能"},"5":{"objectClass":"MindNode","ID":"DWQMB","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"PS8TD","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"D3G15","lineColorHex":"#FFC700","text":"2. 默认值\n使用解构值表达式时，如果指定的局部变量名称也就是要被赋值的变量在对象中不存在，这个局部变量会被赋值为undefined。"},"1":{"objectClass":"MindNode","ID":"132F1","lineColorHex":"#FFC700","text":"3.为非同名局部变量赋值\n使用结构赋值来声明非同名变量，let {type:localType, name :localName} = name;这个含义是，读取type属性值将其存储到localType中，与对象字面量相反，这个值在左对象属性在右。"},"objectClass":"NSArray"},"text":"1. 对象解构\n如果使用var，let或const解构声明变量必须提供初始化。\n给变量赋值时也可以使用解构语法，但是请注意，一定要用一对小括号包裹解构赋值语句，JavaScript引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。"},"1":{"objectClass":"MindNode","ID":"66FE1","lineColorHex":"#FFC700","text":"2. 数组解构\n使用数组字面量，解构操作全部在数组内完成。"},"2":{"objectClass":"MindNode","ID":"R7F65","lineColorHex":"#FFC700","text":"3. 解构参数\n将解构赋值与函数传递参数相结合。默认情况下，调用函数时，不提供被解构的参数会导致程序报错，所以需要提供默认值解决这个问题。解构参数可以代替形参对象来接收多个数据。"},"objectClass":"NSArray"},"text":"解构：使数据访问更便捷\n解构是一种打破数据结构，将其拆分为更小部分的过程。"},"6":{"objectClass":"MindNode","ID":"34L31","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"BL0UJ","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5AHCF","lineColorHex":"#DC306C","text":"let firstName= Symbol();"},"objectClass":"NSArray"},"text":"1. 创建Symbol\n使用全局的Symbol（）函数创建一个Symbol\nSymbol函数可以接收一个可选参数，让你添加一个字符串描述这个Symbol，但是不能用于属性访问。"},"1":{"objectClass":"MindNode","ID":"9P840","lineColorHex":"#DC306C","text":"2. Symbol使用方法\n所有可使用可计算属性名的地方都能用Symbol。"},"2":{"objectClass":"MindNode","ID":"VW2OP","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"U565W","lineColorHex":"#DC306C","text":"使用Symbol.for(）方法创建可共享的Symbol。\n接收一个参数即即将创建的Symbol的字符串标识符。\n\nSymbol.for方法的工作流程是，在注册表中搜索键位uid的Symbol是否存在，存在返回，不存在就创建。"},"objectClass":"NSArray"},"text":"3. Symbol共享体系\n在不同代码中共享同一个Symbol，ES6提供了一个可以随时访问的全局Symbol注册表。"},"3":{"objectClass":"MindNode","ID":"8UKF7","lineColorHex":"#DC306C","text":"Symbol属性检索"},"objectClass":"NSArray"},"text":"Symbol和Symbol属性"},"7":{"objectClass":"MindNode","ID":"0O62S","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5FU17","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"73M3D","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"4J702","lineColorHex":"#BF58F5","text":"let set = new Set()\nset.add(5);\nset.add(\"5\");\nconsole.log(set.size);"},"objectClass":"NSArray"},"text":"1. 创建set集合并添加元素\n调用 new Set（）创建set集合，调用add（）方法向集合添加元素，size属性获取集合元素数量。不会对所存值进行强制的类型转换。多次调用add方法传入相同的值后续的调用会被忽略。\n\n通过has（）方法检测Set集合是否存在某个值。"},"1":{"objectClass":"MindNode","ID":"6GGJE","lineColorHex":"#BF58F5","text":"2. 移除元素\n调用delete（）方法、调用clear（）方法会移除集合所有的元素。"},"2":{"objectClass":"MindNode","ID":"QLK9L","lineColorHex":"#BF58F5","text":"3. set集合的forEach方法\nforEach（）方法的回调函数接收一下三个参数：Set集合中下一次索引的位置· 与第一个参数一样的值· 被遍历的Set集合本身"},"3":{"objectClass":"MindNode","ID":"SJJ23","lineColorHex":"#BF58F5","text":"4. 将set集合转换为数组\n将数组转换为集合只需给set构造函数传入数组即可，将set集合再转回数组，使用展开运算符就可。"},"objectClass":"NSArray"},"text":"1.set集合\n有序列表，含有相互独立不重复的值。"},"1":{"objectClass":"MindNode","ID":"7G711","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"940G6","lineColorHex":"#BF58F5","text":"集合支持3个方法：add()、has()和delete()。\nWeakSet构造函数不接受任何原始值，如果数组包含其他非对象值程序会报错。"},"1":{"objectClass":"MindNode","ID":"48PUC","lineColorHex":"#BF58F5","text":"weakset和set的区别：\n在WeakSet的实例中，如果向add()、has()和delete()这3个方法传入非对象参数都会导致程序报错。\n· Weak Set集合不可迭代，所以不能被用于for-of循环。\n· Weak Set集合不暴露任何迭代器（例如keys()和values()方法），所以无法通过程序本身来检测其中的内容。\n· Weak Set集合不支持forEach()方法。· Weak Set集合不支持size属性。"},"objectClass":"NSArray"},"text":"2. weak set\n将对象存储在Set实例中，只要Set实例引用存在，对象的内存空间就不会被释放。所以要引入WeakSet集合。"},"2":{"objectClass":"MindNode","ID":"RI7B6","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"Z8G52","lineColorHex":"#BF58F5","text":"1.  向Map集合添加新元素使用set（）方法\n分别传入键名和对应值作为两个参数。"},"1":{"objectClass":"MindNode","ID":"2FKG2","lineColorHex":"#BF58F5","text":"2. get（）方法\n从map集合中获取信息。传入键名就可以返回相应的键值。"},"2":{"objectClass":"MindNode","ID":"3I632","lineColorHex":"#BF58F5","text":"3. 与set一样支持has（）、delete（）、clear（）和size属性。"},"3":{"objectClass":"MindNode","ID":"O2X53","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"28G91","lineColorHex":"#BF58F5","text":"1. 可以向Map构造函数传入一个数组来初始化。数组的每个元素都是一个子数组，子数组包含一个键值对。"},"objectClass":"NSArray"},"text":"4. Map集合初始化的方法"},"objectClass":"NSArray"},"text":"3. map集合\n一种存储许多键值对的有序列表。可以使用对象作为键名。"},"3":{"objectClass":"MindNode","ID":"SB39Q","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1W6RF","lineColorHex":"#BF58F5","text":"作用：\nWeak Map集合最大的用途是保存Web页面中的DOM元素，例如，一些为Web页面打造的JavaScript库，会通过自定义的对象保存每一个引用的DOM元素。"},"objectClass":"NSArray"},"text":"4. WeakMap\n用。Weak Map集合中的键名必须是一个对象，如果使用非对象键名会报错。"},"objectClass":"NSArray"},"text":"set集合和map集合"},"8":{"objectClass":"MindNode","ID":"1JDO3","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"T1D3O","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"AHUQB","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"GTGFV","lineColorHex":"#26BBFF","text":"let iterator = creatIterator([1,2,3]);\n\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next())"},"objectClass":"NSArray"},"text":"ES5语法创建：\nfunction creatIterator(items){\n    let i = 0;\n    return{\n        next(){\n            let done = (i>=items.length);\n            let value = !done?items[i++]:undefined;\n\n            return {\n                done,\n                value\n            }\n        }\n    }\n}"},"objectClass":"NSArray"},"text":"1.迭代器\n迭代器是一种特殊的对象，有一些专门为迭代过程设计的撰有接口，所有的迭代对象都有一个next（）方法，每次调用都返回一个结果对象。结果对象有两个属性 value返回的值，另一个是done布尔值当没有更多可返回的数据时返回true。"},"1":{"objectClass":"MindNode","ID":"7Y936","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"38PLN","lineColorHex":"#26BBFF","text":"yield关键字，指定调用迭代器的next（）方法时的返回值和返回顺序。生成器函数，每当执行完一条yield语句会自动停止执行，直到再次调用迭代器next（）方法。"},"objectClass":"NSArray"},"text":"2. 生成器\n生成器是一种返回迭代器的函数，通过function关键字后的* 来表示，函数中会用到关键字yield。"},"2":{"objectClass":"MindNode","ID":"13WC7","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"ASX17","lineColorHex":"#26BBFF","text":"for-of循环：\nfor-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true。"},"1":{"objectClass":"MindNode","ID":"S63MO","lineColorHex":"#26BBFF","text":"创建可迭代对象：\n开发者定义的对象都是不可迭代对象，给Symbols.iterator属性添加一个生成器，则变为可迭代对象。"},"objectClass":"NSArray"},"text":"3. 可迭代对象和for-of循环\n所有的集合对象和字符串都是可迭代对象。"},"3":{"objectClass":"MindNode","ID":"G7P7J","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"OR8W8","lineColorHex":"#26BBFF","text":"第八章"},"objectClass":"NSArray"},"text":"4. 内建迭代器","markType":6},"4":{"objectClass":"MindNode","ID":"8GG8T","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"312T1","lineColorHex":"#26BBFF","text":"1. 给迭代器传递参数\n如果给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值。"},"objectClass":"NSArray"},"text":"5. 高级迭代器功能","markType":7},"5":{"objectClass":"MindNode","ID":"23Y8P","lineColorHex":"#26BBFF","text":"6. 异步任务执行","markType":7},"objectClass":"NSArray"},"text":"迭代器和生成器"},"9":{"objectClass":"MindNode","ID":"7GM7N","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"WKY45","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"935FX","lineColorHex":"#37C45A","text":"Array.of（）方法\nArray.of()与Array构造函数的工作机制类似，只是不存在单一数值型参数值的特例，无论有多少参数，无论参数是什么类型的，Array.of()方法总会创建一个包含所有参数的数组。"},"1":{"objectClass":"MindNode","ID":"6PD24","lineColorHex":"#37C45A","text":"Array.from()方法\n可以接受可迭代对象或类数组对象作为第一个参数，最终返回一个数组。可以提供一个映射函数作为Array.from()的第二个参数，这个函数用来将类数组对象中的每一个值转换成其他形式，最后将这些结果储存在结果数组的相应索引中。也可以给Array.from()方法传入第三个参数来表示映射函数的this值。","markType":7},"objectClass":"NSArray"},"text":"1.创建数组"},"1":{"objectClass":"MindNode","ID":"8H4VF","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"XU464","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"X55U3","lineColorHex":"#37C45A","text":"二者间唯一的区别是，find()方法返回查找到的值，findIndex()方法返回查找到的值的索引。"},"objectClass":"NSArray"},"text":"find（）以及findindex（）方法：\nfind()方法和findIndex()方法都接受两个参数：一个是回调函数；另一个是可选参数，用于指定回调函数中this的值。执行回调函数时，传入的参数分别为：数组中的某个元素和该元素在数组中的索引及数组本身，与传入map()和forEach()方法的参数相同。"},"1":{"objectClass":"MindNode","ID":"H3T6C","lineColorHex":"#37C45A","text":"fill（）方法：\n第一个参数是改变数组元素的目标值，第二个第三个参数可以指定起始和结束得索引。"},"2":{"objectClass":"MindNode","ID":"ZW8PG","lineColorHex":"#37C45A","text":"copyWithin（）方法：\ncopyWithin()方法则是从数组中复制元素的值。调用copyWithin()方法时需要传入两个参数：一个是该方法开始填充值的索引位置，另一个是开始复制值的索引位置。"},"objectClass":"NSArray"},"text":"2. 为所有数组添加新方法"},"2":{"objectClass":"MindNode","ID":"13R2U","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"7665X","lineColorHex":"#37C45A","text":"定型数组是一种用于处理数值类型（正如其名，不是所有类型）数据的专用数组。"},"objectClass":"NSArray"},"text":"3. 定型数组"},"objectClass":"NSArray"},"text":"改进数组的功能"},"10":{"objectClass":"MindNode","ID":"84YPY","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"41EW3","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"Y0JG7","lineColorHex":"#1BD6E7","text":"JavaScript引擎是基于单线程（Single-threaded）事件循环的概念构建的，同一时刻只允许一个代码块在执行。\n\n所以需要跟踪即将运行的代码，那些代码被放在一个任务队列（job queue）中，每当一段代码准备执行时，都会被添加到任务队列。"},"1":{"objectClass":"MindNode","ID":"44Q4U","lineColorHex":"#1BD6E7","text":"事件模型：\n事件模型适用于处理简单的交互，然而将多个独立的异步调用连接在一起会使程序更加复杂，因为你必须跟踪每个事件的事件目标"},"2":{"objectClass":"MindNode","ID":"TG8L2","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"W7254","lineColorHex":"#1BD6E7","text":"readFile（参数1，回调函数）\n由于使用了回调模式，readFile()函数立即开始执行，当读取磁盘上的文件时会暂停执行。将同步代码先执行。当readFile()结束执行时，会向任务队列的末尾添加一个新任务，该任务包含回调函数及相应的参数，当队列前面所有的任务完成后才执行该任务，并最终执行console.log(contents)输出所有内容。"},"objectClass":"NSArray"},"text":"回调模式：\nNode.js通过普及回调函数来改进异步编程模型，回调模式与事件模型类似，异步代码都会在未来的某个时间点执行，二者的区别是回调模式中被调用的函数是作为参数传入的。\n\n就是一个匿名函数，是在一个函数调用中作为参数，它不会在被调用函数的函数体中被调用，而是当被调用函数执行完毕后，会将这个匿名函数参数添加到任务队列的末尾。"},"objectClass":"NSArray"},"text":"1. 异步编程的背景知识"},"1":{"objectClass":"MindNode","ID":"M81G4","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"065AW","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"BX28X","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"HICDZ","lineColorHex":"#1BD6E7","text":"所有Promise都有then()方法，它接受两个参数：\n第一个是当Promise的状态变为fulfilled时要调用的函数，第二个是当Promise的状态变为rejected时要调用的函数。"},"1":{"objectClass":"MindNode","ID":"MYJQV","lineColorHex":"#1BD6E7","text":"Promise还有一个catch()方法，相当于只给其传入拒绝处理程序的then()方法。then()方法和catch()方法一起使用才能更好地处理异步操作结果。"},"objectClass":"NSArray"},"text":"内部属性[[PromiseState]]被用来表示Promise的3种状态：\"pending\"、\"fulfilled\"及\"rejected\"。不能检测。只能通过then（）方法采取特定的行动。"},"1":{"objectClass":"MindNode","ID":"7J1TT","lineColorHex":"#1BD6E7","text":"如果一个Promise处于已处理状态，在这之后添加到任务队列中的处理程序仍将执行。所以无论何时你都可以添加新的完成处理程序或拒绝处理程序，同时也可以保证这些处理程序能被调用。"},"objectClass":"NSArray"},"text":"1、Promise声明周期\n有三种状态先是处于进行中（pending）的状态，此时操作尚未完成，所以它也是未处理（unsettled）的；一旦异步操作执行结束，Promise则变为已处理（settled）的状态。\n\n操作结束之后，Promise可能会进入Fulfilled 和Rejected中的一个。","maxWidthLine":306},"1":{"objectClass":"MindNode","ID":"44QM4","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"WXL05","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"87MI0","lineColorHex":"#1BD6E7","text":"readFile()方法被调用时执行器会立刻执行，在执行器中，无论是调用resolve()还是reject()，都会向任务队列中添加一个任务来解决这个Promise。调用resolve()后会触发一个异步操作，传入then()和catch()方法的函数会被添加到任务队列中并异步执行。"},"objectClass":"NSArray"},"text":"执行器接受两个参数，分别是resolve函数和reject函数。执行器成功完成时调用resolve，失败调用reject函数。"},"objectClass":"NSArray"},"text":"2. 创建未完成的Promise\n用Promise构造函数可以创建新的Promise，构造函数只接受一个参数：包含初始化Promise代码的执行器（executor）函数。"},"2":{"objectClass":"MindNode","ID":"KPX11","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"6JG71","lineColorHex":"#1BD6E7","text":"Promise.resolve(）方法\nPromise.resolve()方法只接受一个参数并返回一个完成态的Promise，也就是说不会有任务编排的过程，而且需要向Promise添加一至多个完成处理程序来获取值。"},"1":{"objectClass":"MindNode","ID":"MEO8W","lineColorHex":"#1BD6E7","text":"Promise.reject()方法\n它与Promise.resolve()很像，唯一的区别是创建出来的是拒绝态的Promise"},"objectClass":"NSArray"},"text":"3. 创建已完成的Promise"},"3":{"objectClass":"MindNode","ID":"NK6BI","lineColorHex":"#1BD6E7","text":"4. 全局的Promise拒绝处理","markType":7},"4":{"objectClass":"MindNode","ID":"P66VS","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"76EL1","lineColorHex":"#1BD6E7","text":"每次调用then()方法或catch()方法时实际上创建并返回了另一个Promise，只有当第一个Promise完成或被拒绝后，第二个才会被解决。"},"1":{"objectClass":"MindNode","ID":"KOB98","lineColorHex":"#1BD6E7","text":"可以通过Promise的catch方法的拒绝处理程序接受这个错误。"},"2":{"objectClass":"MindNode","ID":"R7224","lineColorHex":"#1BD6E7","text":"Promise链的返回值\n从执行器resolve（）处理程序到promise完成处理程序是通过resolve的参数传递的，当第一个完成了给第二个完成处理程序传递参数需要用到return。"},"objectClass":"NSArray"},"text":"5. 串联多个Promise"},"5":{"objectClass":"MindNode","ID":"2V31J","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"72166","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"14DG8","lineColorHex":"#1BD6E7","text":"所有传入Promise.all()方法的Promise只要有一个被拒绝，那么返回的Promise没等所有Promise都完成就立即被拒绝"},"objectClass":"NSArray"},"text":"Promise.all()方法\nPromise.all()方法只接受一个参数并返回一个Promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有当可迭代对象中所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成"},"1":{"objectClass":"MindNode","ID":"U7NW8","lineColorHex":"#1BD6E7","text":"Promise.race()方法监听多个Promise的方法稍有不同：它也接受含多个受监视Promise的可迭代对象作为唯一参数并返回一个Promise，但只要有一个Promise被解决返回的Promise就被解决，无须等到所有Promise都被完成。"},"objectClass":"NSArray"},"text":"6.响应多个Promise"},"6":{"objectClass":"MindNode","ID":"K4D51","lineColorHex":"#1BD6E7","text":"7. 基于promise的异步任务执行","markType":7},"objectClass":"NSArray"},"text":"2. Promise基础知识"},"objectClass":"NSArray"},"text":"Promise与异步编程"},"11":{"objectClass":"MindNode","ID":"9D11X","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"5HL62","lineColorHex":"#FFC700","text":"代理和反射\n"},"objectClass":"NSArray"},"text":"代理（Proxy）和反射（Reflection）API"},"objectClass":"NSArray"},"text":"ES6"},"ID":"3KXCN","style":100}