{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"XB2DU","rootPoint":{"objectClass":"CGPoint","x":360,"y":3534},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"QO8NY","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"6NJ1L","lineColorHex":"#DC306C","text":"网页是一个多层的结构，通过css可以分别为每一层设置样式，作为用户只能看到顶层，这些层中最下一层是文档流，文档流是基础。我们所创建的元素默认都是在文档流中进行排列的。\n\n元素主要有两个状态：\n在文档流中 和不在文档流中"},"1":{"objectClass":"MindNode","ID":"4DCVI","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"B3X38","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1E7E0","lineColorHex":"#DC306C","text":"块元素会在页面中独占一行\n默认宽度是父元素的全部\n默认高度是被内容撑开的"},"objectClass":"NSArray"},"text":"块元素\ndisplay设置为block，block值可应用到所有元素"},"1":{"objectClass":"MindNode","ID":"O8086","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"28B68","lineColorHex":"#DC306C","text":"行内元素不会独占一行，只占自身大小，在页面中自左向右水平排列。\n行内元素的宽高都是被内容撑开的。浏览器会忽略某些属性，如width、height和margin。"},"objectClass":"NSArray"},"text":"行内元素\ndisplay属性设置为inline值会创建一个行内元素，它在视觉上跟周围内容的显示没有区别。"},"2":{"objectClass":"MindNode","ID":"466P4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5T113","lineColorHex":"#DC306C","text":"盒子整体上作为行内元素显示，这意味着垂直方向上该元素和周围的内容并排显示，没有区别。但盒子内部作为块元素显示，这样，width、height和margin属性都能应用到盒子上。"},"objectClass":"NSArray"},"text":"行内-块级元素\n将display属性设置为inline-block值会创建一个其盒子混合了块和行内特征的元素。"},"3":{"objectClass":"MindNode","ID":"32414","lineColorHex":"#DC306C","text":"认识插入元素\ndisplay属性设置为run-in值会创建一个这样的元素：其盒子类型取决于周围元素。","markType":7},"4":{"objectClass":"MindNode","ID":"4OP76","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"4N8M3","lineColorHex":"#DC306C","text":"将display属性设置为none值就是告诉浏览器不要为元素创建任何类型的盒子，也就是说元素没有后代元素。这时元素在页面布局中不占据任何空间。"},"objectClass":"NSArray"},"text":"隐藏元素"},"objectClass":"NSArray"},"text":"在文档流中的特点："},"objectClass":"NSArray"},"text":"文档流"},"1":{"objectClass":"MindNode","ID":"DO8QL","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"V60HP","lineColorHex":"#BF58F5","text":"CSS将页面中的所有元素都设置为了一个矩形的盒子。\n内容和边框是可见的，内边距是内容和边框之间的空间，外边距是边框和页面上其他元素之间的空间。"},"1":{"objectClass":"MindNode","ID":"HI67P","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2M61G","lineColorHex":"#BF58F5","text":"内容区（content）：元素中的所有子元素和文本内容都在内容区中排列，内容区大小由width和height设置，并不是设置了整个盒子的宽高。"},"1":{"objectClass":"MindNode","ID":"68FR4","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"L518C","lineColorHex":"#BF58F5","text":"这些边框属性都是简写属性：\nborder-width 四个方向的边框的宽度的值的情况： 四个值：上 右 下 左\n          三个值：上 左右 下\n           两个值：上下 左右\n这几种情况是通用。都可以分别为每个边设置。"},"1":{"objectClass":"MindNode","ID":"6DN91","lineColorHex":"#BF58F5","text":"border简写属性：通过该属性可以同时设置所有的相关样式，并且没有顺序要求。"},"objectClass":"NSArray"},"text":"边框(border)：属于盒子边缘，出了边框都属于盒子的外部，可以设置三个样式。\n\nborder-style属性用来定义边框的样式\nborder-width 属性为边框指定宽度\nborder-color 属性用于设置边框的颜色"},"2":{"objectClass":"MindNode","ID":"3K7WH","lineColorHex":"#BF58F5","text":"内边距/填充区（padding）：也是一个简写属性，可以单独为四个方向设置填充区样式。\n\n内边距的设置会影响到盒子大小，背景颜色会延申到填充去上，"},"3":{"objectClass":"MindNode","ID":"EQ647","lineColorHex":"#BF58F5","text":"外边距（margin）：\n外边距不会影响可见框的大小，但是外边距会影响盒子的位置，一共有四个方向的margin。margin 没有背景颜色，是完全透明的。\n\n设置向下向右的外边距时，会移动其他元素。"},"objectClass":"NSArray"},"text":"内容盒（content）\n边框（border）\n填充区（padding）\n外边距（margin）\n\n一个盒子可见的大小，由内容区、内边距、边框共同决定的，计算盒子大小时，需要将三个区域加到一起计算。"},"2":{"objectClass":"MindNode","ID":"K8B0N","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"OE5TF","lineColorHex":"#BF58F5","text":"水平布局：\n元素在其父元素中水平方向的位置由以下几个属性共同决定，左右外边距、左右边框、左右填充区、还有子元素的内容区，一共七个值，它们相加必须等于父元素的内容盒的宽度。如果等式不成立，浏览器会自动调整\n\n调整情况：七个值没有auto的情况下，则浏览器会自动调整margin-right值以使等式成立。\n\n七个值中有三个可以设置为auto，width margin-left margin-right，如果某个值为auto，会自动调整为auto的那个值以使等式成立。如果宽度和margin都设为auto，优先计算width。\n\nmargin-left和margin-rigth设置为auto，定宽，就可以使子元素在父元居中。"},"1":{"objectClass":"MindNode","ID":"8I226","lineColorHex":"#BF58F5","text":"垂直方向布局：\n默认情况下不设置高度的情况下，父元素的高度被内容撑开。\n使用overflow属性来设置父元素如何处理溢出的子元素。"},"2":{"objectClass":"MindNode","ID":"8SR58","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"DV5N8","lineColorHex":"#BF58F5","text":"相邻的垂直方向上的外边距会发生重叠现象。兄弟元素间的外边距折叠，不需要处理。"},"1":{"objectClass":"MindNode","ID":"N47GE","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6TI4K","lineColorHex":"#BF58F5","text":"解决方法：\n1.给父元素加padding-top，但是就需要更改高度。\n2. 给父元素加border-top，将父子元素的外边距隔开。"},"objectClass":"NSArray"},"text":"父子元素间的上外边距，子元素会传递给父元素，设置子元素的上外边距的时候相当于给父元素设置了上外边距，所以它们会一起移动"},"objectClass":"NSArray"},"text":"外边距的折叠问题"},"objectClass":"NSArray"},"text":"盒子模型的布局"},"3":{"objectClass":"MindNode","ID":"55726","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"D8SZ8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6ID14","lineColorHex":"#BF58F5","text":"overflow-x、overflow-y设置水平和垂直方向的溢出方法。\n\n可以取值，hidden 多余的部分被剪掉\nscroll 添加滚动条机制\nvisible 默认值 始终显示"},"objectClass":"NSArray"},"text":"当容器元素指定了绝对的宽高后，元素内的内容若是溢出了可以使用overflow属性改变这种行为。"},"objectClass":"NSArray"},"text":"处理溢出内容"},"4":{"objectClass":"MindNode","ID":"562PN","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"R7STH","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1DX9H","lineColorHex":"#BF58F5","text":"Chrome，根本不支持collapse值。"},"objectClass":"NSArray"},"text":"visibility属性控制元素的可见性，可以取值为collapse 元素不可见在页面布局中不占据空间、hidden 元素不可见在页面布局中占据空间、visible 默认值 可见。"},"objectClass":"NSArray"},"text":"控制元素的可见性"},"5":{"objectClass":"MindNode","ID":"J8526","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"E8735","lineColorHex":"#BF58F5","text":"display属性提供了一种改变元素盒类型的方式，这相应会改变元素在页面上的布局方式。"},"objectClass":"NSArray"},"text":"设置元素的盒类型"},"objectClass":"NSArray"},"text":"盒子模型"},"2":{"objectClass":"MindNode","ID":"7C7ES","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"Q6WU2","lineColorHex":"#26BBFF","text":"行内元素不支持设置宽度和高度\n\npadding、border、margin垂直方向上的不会影响布局。浏览器会忽略某些属性，如width、height和margin。"},"1":{"objectClass":"MindNode","ID":"KN4NG","lineColorHex":"#26BBFF","text":"display：用来设置元素显示类型\ninline 行内元素\nblock 元素为块元素\ninline-block： 行内块元素\n     行内块，又可以设置宽高且不会独占一行\n\nvisibili 用来设置显示状态\n可选值hidden 不显示，但是依然占有页面的位置。"},"objectClass":"NSArray"},"text":"行内元素的盒子模型"},"3":{"objectClass":"MindNode","ID":"5GY4R","lineColorHex":"#37C45A","text":"浏览器的默认样式：\n通常情况下PC端下，必须要去除浏览器的默认样式。\n可以引用别人写好的css文件。"},"4":{"objectClass":"MindNode","ID":"7XC7H","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"4224R","lineColorHex":"#1BD6E7","text":"通过浮动使一个元素向其父元素的左侧或右侧移动，可选值 none left向左浮动 right向右浮动。"},"1":{"objectClass":"MindNode","ID":"12WSB","lineColorHex":"#1BD6E7","text":"注意：\n元素设置浮动以后，水平布局的等式不需要强制成立。并且会完全从文档流中脱离，不再占用文档流中的位置，所以元素下边的还在文档流中的元素会自动向上移动补上去。"},"2":{"objectClass":"MindNode","ID":"4663J","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"I98T1","lineColorHex":"#1BD6E7","text":"脱离文档后的特点：\n块元素：\n1. 块元素不会独占一行\n2. 块元素宽度和高度都被内容撑开\n\n行内元素：\n1. 行内元素会变成块元素\n\n脱离文档流以后，不用再区分行内和块元素"},"objectClass":"NSArray"},"text":"特点：\n1. 浮动元素会完全脱离文档流，不再占用文档流中的位置。\n2. 设置浮动元素会向父元素的左侧或右侧移动。\n3. 浮动元素不会从父元素中溢出。\n4. 浮动元素向左或向右移动时，不会超过覆盖其他的浮动元素一个挨着一个的。\n5. 如果浮动元素上边有一个文档流块元素，浮动元素是不会向上移动的，因为块元素独占一行。\n6. 浮动元素不会覆盖住文字，文字会自动环绕浮动元素周围。\n7。 元素设置浮动后，脱离文档流后，元素的一些特点也会发生变化。"},"3":{"objectClass":"MindNode","ID":"J5GK7","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"INXLY","lineColorHex":"#1BD6E7","text":"高度坍塌：\n在浮动布局中，父元素高度没有设置的时候，高度默认是被子元素撑开的。但当给子元素设置浮动的时候，子元素脱离文档流，导致父元素的高度丢失。\n父元素高度丢失以后，其下元素会自动上移，导致页面布局混乱。所以高度坍塌是一个常见的问题必须解决。"},"1":{"objectClass":"MindNode","ID":"39QIU","lineColorHex":"#1BD6E7","text":"BFC 块级格式化环境：\n开启BFC后该元素会变成一个独立的布局区域。\n开启BFC的特点：\n1. 开启BFC的元素不会被浮动元素覆盖\n2. 子元素和父元素的外边距不会重叠\n3. 开启BFC的元素可以包含浮动的子元素"},"2":{"objectClass":"MindNode","ID":"0S00G","lineColorHex":"#1BD6E7","text":"clear：\n作用 清除浮动元素对当前元素产生的影响：\n可选值：left right both（清除两侧中影响最大的）\n原理：\n设置清除浮动以后，浏览器会自动为元素加一个外边距，使其位置不受浮动元素的影响"},"3":{"objectClass":"MindNode","ID":"GW2JU","lineColorHex":"#1BD6E7","text":"使用aftter伪元素解决高度坍塌：\n.clearfix   "},"objectClass":"NSArray"},"text":"高度坍塌和BFC"},"objectClass":"NSArray"},"text":"浮动"},"5":{"objectClass":"MindNode","ID":"U5635","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"B6W22","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"L2EUW","lineColorHex":"#FFC700","text":"相对定位：\n1.开启定位后如果设置偏移量是不会有任何变化的，偏移量有四个top bottom left right，这四个值同margin很像，值越大就离多远。\n\n2. 相对定位是参照于元素在文档流中的位置进行定位的。\n\n3. 相对定位会提升元素的层级\n\n4. 相对定位不会使元素脱离文档流\n\n5.相对定位不会改变元素性质。"},"1":{"objectClass":"MindNode","ID":"8P18C","lineColorHex":"#FFC700","text":"绝对定位：\n1.开启绝对定位后，元素会脱离文档流。\n2. 绝对定位会改变元素的性质。\n3.绝对定位元素是相对于开启了定位的包含块（祖先块元素）\n4. 如果没有开启定位的父元素，就会根据html来定位。"},"2":{"objectClass":"MindNode","ID":"BKGJ6","lineColorHex":"#FFC700","text":"固定定位：\n也是一种绝对定位，根据视口进行定位的。\n"},"3":{"objectClass":"MindNode","ID":"4OM39","lineColorHex":"#FFC700","text":"粘滞定位：\nfixed,根据窗口定位."},"objectClass":"NSArray"},"text":"定位可以将元素摆放在页面的任意位置。\n有五个值：\nstatic\nrelative\nabsolute\nfixed\nsticky"},"1":{"objectClass":"MindNode","ID":"OAH64","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"E327D","lineColorHex":"#FFC700","text":"对于开启了定位元素，可以通过z-index属性来设定元素的层级z-index需要一个整数作为参数，值越大层级越高越优先显示。\n\n祖先元素的层级再高，也不会盖住后代元素。"},"objectClass":"NSArray"},"text":"元素的层级"},"objectClass":"NSArray"},"text":"定位"},"6":{"objectClass":"MindNode","ID":"F0FWS","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"G7ROP","lineColorHex":"#DC306C","text":"第二十章 21.2"},"objectClass":"NSArray"},"text":"创建多列布局"},"7":{"objectClass":"MindNode","ID":"6F1MT","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"R3332","lineColorHex":"#BF58F5","text":"弹性盒布局（也称为伸缩盒）在CSS3中得到了进一步增强，为display属性添加了一个新值（flexbox），并定义了其他几个属性。\n\n这是通过在包含元素之间分配容器块中未使用的空间来实现的。"},"1":{"objectClass":"MindNode","ID":"9NI19","lineColorHex":"#BF58F5","text":"1. 可以修改排列方式\n如果我们设置 direction 属性为 rtl (right-to-left),弹性子元素的排列方式也会改变，页面布局也跟着改变。 这可以给包含弹性容器的父元素设置。"},"2":{"objectClass":"MindNode","ID":"WYSNI","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"818KY","lineColorHex":"#BF58F5","text":"flex-direction的值有:\n\nrow：横向从左到右排列（左对齐），默认的排列方式。\nrow-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。\ncolumn：纵向排列。\ncolumn-reverse：反转纵向排列，从后往前排，最后一项排在最上面。"},"objectClass":"NSArray"},"text":"2. felx-direction\nflex-direction 顺序指定了弹性子元素在父容器中的位置。\n语法：flex-direction: row | row-reverse | column | column-reverse"},"3":{"objectClass":"MindNode","ID":"PQMG8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"0Q3IE","lineColorHex":"#BF58F5","text":"容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。"},"1":{"objectClass":"MindNode","ID":"4FK3F","lineColorHex":"#BF58F5","text":"五个取值：\nflex-start（默认值）：左对齐\nflex-end：右对齐\ncenter： 居中\nspace-between：两端对齐，项目之间的间隔都相等。\nspace-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。"},"objectClass":"NSArray"},"text":"3. justify-content属性\n内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。"},"4":{"objectClass":"MindNode","ID":"OU06Y","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"QN2LC","lineColorHex":"#BF58F5","text":"五个取值：\nflex-start：交叉轴的起点对齐。\nflex-end：交叉轴的终点对齐。\ncenter：交叉轴的中点对齐。\nbaseline: 项目的第一行文字的基线对齐。\nstretch（默认值）：如果项目（也就是弹性容器内的弹性子元素）未设置高度或设为auto，将占满整个容器的高度。"},"objectClass":"NSArray"},"text":"4. align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}"},"5":{"objectClass":"MindNode","ID":"7QUM4","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"QLZ8E","lineColorHex":"#BF58F5","text":"nowrap - 默认，弹性容器为单行。该情况下弹性子项可能会溢出容器。\nwrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行\nwrap-reverse -反转 wrap 排列。"},"objectClass":"NSArray"},"text":"5.flex-wrap属性\nflex-wrap 属性用于指定弹性盒子的子元素换行方式。\nflex-wrap: nowrap|wrap|wrap-reverse|initial|inherit; "},"6":{"objectClass":"MindNode","ID":"MH928","lineColorHex":"#BF58F5","text":"6. flex-flow属性\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。"},"7":{"objectClass":"MindNode","ID":"SZ2W7","lineColorHex":"#BF58F5","text":"7. align-content属性\nalign-content 属性用于修改 flex-wrap 属性的行为。类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。"},"8":{"objectClass":"MindNode","ID":"NXI69","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"7BX84","lineColorHex":"#BF58F5","text":"1、order属性\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。"},"1":{"objectClass":"MindNode","ID":"26EIH","lineColorHex":"#BF58F5","text":"2、flex-grow属性\nflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"},"2":{"objectClass":"MindNode","ID":"R5B53","lineColorHex":"#BF58F5","text":"3.flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"},"objectClass":"NSArray"},"text":"弹性子元素属性"},"objectClass":"NSArray"},"text":"创建弹性盒布局"},"objectClass":"NSArray"},"text":"CSS布局"},"ID":"VF7C3","style":100}