{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"OKI05","rootPoint":{"objectClass":"CGPoint","x":360,"y":3483.5},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"81033","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2H06K","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"DPMU9","lineColorHex":"#DC306C","text":"创建数组：\n1. 最简单的方式是\nvar 变量名 = [ ] ;\n\n2. 使用Array的构造函数创建\nvar 变量名 = new Array[]\n\n注意使用构造函数时，传递一个参数时定义的是数组长度。\n并且，数组中的元素不必是同一种数据类型，可以使用Array.isArray()来判断一个对象是否是数组。"},"1":{"objectClass":"MindNode","ID":"I5423","lineColorHex":"#DC306C","text":"读写数组：\n最简单的使用 [ ]来进行读写，同其他语言一样。"},"2":{"objectClass":"MindNode","ID":"H8DLL","lineColorHex":"#DC306C","text":"由字符串生成数组：\n调用字符串对象的split（）方法可以生成数组。通过一些常见的分隔符，比如分割单词的空格，将一个字符串分成几部分，并保存在新建的数组中。"},"3":{"objectClass":"MindNode","ID":"C2N73","lineColorHex":"#DC306C","text":"对数组的整体性操作：\n也就是将一个数组赋值给另一个数组，但是分为浅拷贝和深拷贝。深拷贝，将原数组中每一个元素都复制一份给新数组，前提是数组指针指向的是不同的数组对象。"},"objectClass":"NSArray"},"text":"使用数组"},"1":{"objectClass":"MindNode","ID":"95Q68","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"Q56N3","lineColorHex":"#DC306C","text":"有两个方法可以将数组转化为字符串：\njoin（）和toString（），都返回一个包含数组所有元素的字符串，个元素之间用逗号分隔开。可以给join传指定的分隔符号比如空格或者没有分隔符。"},"1":{"objectClass":"MindNode","ID":"02757","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"W62E4","lineColorHex":"#DC306C","text":"concat（）的参数是另一个数组。"},"1":{"objectClass":"MindNode","ID":"XN1HN","lineColorHex":"#DC306C","text":"splice（）该方法的第一个参数是截取的起始索引，第二个参数是截取的长度，第三个及以后的参数可以是添加的新元素。"},"objectClass":"NSArray"},"text":"由已有数组创建新数组：\nconcat()和splice（）方法允许通过已有数组创建新数组。concat方法可以合并多个数组创建一个新数组，splice()方法截取一个数组的子集创建一个新数组。\n它们都会返回一个新数组，并不会改变原来的数组结构。"},"objectClass":"NSArray"},"text":"存取函数（数组）"},"2":{"objectClass":"MindNode","ID":"87W12","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"37Y35","lineColorHex":"#DC306C","text":"添加元素：\npush()方法会将一个元素添加到数组末尾，也可以使用数组的length属性为数组添加元素因为length是索引+1.\nunshift()方法可以将元素添加在数组的开头。\n这两种方法都改变自身数组。"},"1":{"objectClass":"MindNode","ID":"D34XW","lineColorHex":"#DC306C","text":"删除元素：\n使用pop()方法可以删除数组末尾的元素。\nshift()方法可以删除数组的第一个元素。\npop()和shift()方法都将删掉的元素作为方法的返回值返回，因此可以使用一个变量来保存删除的元素"},"2":{"objectClass":"MindNode","ID":"8232U","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"22RJ4","lineColorHex":"#DC306C","text":"b大于a时，这段代码会返回负数，反之则返回正数。如果相等的话，就会返回0。也就是说返回的是负数，就说明a比b小，这样sort就能根据返回值的情况对数组进行排序。"},"1":{"objectClass":"MindNode","ID":"X64RO","lineColorHex":"#DC306C","text":"字符串排序是根据ASCII值来比较的。"},"objectClass":"NSArray"},"text":"数组排序：\n第一个方法是reverse()，该方法将数组中元素的顺序进行翻转。\nsort（）方法，对数字类型进行排序效果不好，为了让sort()方法也能排序数字类型的元素，可以在调用方法时传入一个大小比较函数，第一个参数减第二个参数则从小到大排序反之从大到小。"},"objectClass":"NSArray"},"text":"可变函数\nJavaScript拥有一组可变函数，使用它们，可以不必引用数组中的某个元素，就能改变数组内容。"},"3":{"objectClass":"MindNode","ID":"LK63O","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"SZ381","lineColorHex":"#DC306C","text":"forEach（）：\n不产生任何新数组也不会改变原数组的值，是对数组中每个元素执行某种操作或者返回一个值。","summaries":{"0":{"objectClass":"NodeSummary","ID":"5U7Z2","text":"不生成新数组的方法","offset":{"objectClass":"CGPoint","x":0,"y":0}},"objectClass":"NSArray"}},"1":{"objectClass":"MindNode","ID":"ZIDR3","lineColorHex":"#DC306C","text":"every（）：\n该方法接受一个返回值为布尔类型的函数，对数组中的每个元素使用该函数。如果对于所有的元素，均返回true，则该方法返回true。如果有一个元素迭代为flase则会直接返回false，余下的元素不检测。"},"2":{"objectClass":"MindNode","ID":"8R47Y","lineColorHex":"#DC306C","text":"some（）：\nsome()方法也接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回true，该方法就返回true。"},"3":{"objectClass":"MindNode","ID":"5U7Z2","lineColorHex":"#DC306C","text":"reduce（）：\nreduce()方法接受一个函数，返回一个值。该方法会从一个累加值开始，不断对累加值和数组中的后续元素调用该函数，直到数组中的最后一个元素，最后返回得到的累加值。所以还可以连接字符串。"},"4":{"objectClass":"MindNode","ID":"7F1JM","lineColorHex":"#DC306C","text":"map（）：\nmap()返回一个新的数组，该数组的元素是对原有元素应用某个函数得到的结果。"},"5":{"objectClass":"MindNode","ID":"EC8WU","lineColorHex":"#DC306C","text":"filter（）：\n和every()方法不同的是，当对数组中的所有元素应用该函数，结果均为true时，该方法并不返回true，而是返回一个新数组，该数组包含应用该函数后结果为true的元素。不会对原数组进行改变。"},"objectClass":"NSArray"},"text":"迭代器方法\n这些方法对数组中的每个元素应用一个函数，可以返回一个值、一组值或者一个新数组。"},"4":{"objectClass":"MindNode","ID":"LIJ43","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"2CBDK","lineColorHex":"#DC306C","text":"创建二维数组：\n1. 简单方法通过一维数组中的元素也设定为数组，就可以创建二维数组，对于小规模数据。\n2. 使用拓展方法\nArray.matrix通过传递行数，列数，初始值来进行创建二维数组。"},"objectClass":"NSArray"},"text":"二维和多维数组"},"5":{"objectClass":"MindNode","ID":"B4IX2","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"Q339W","lineColorHex":"#DC306C","text":"也就是存放的是对象类型的元素。"},"objectClass":"NSArray"},"text":"对象数组"},"6":{"objectClass":"MindNode","ID":"HDMBF","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"B76II","lineColorHex":"#DC306C","text":"indexOf（）函数：\n用来查找传进来的参数在目标数组中是否存在。如果目标数组包含该参数，就返回该元素在数组中的索引；如果不包含，就返回-1。\n\nlastIndexOf()，该函数返回相同元素中最后一个元素的索引，如果没找到相同元素，则返回-1。"},"1":{"objectClass":"MindNode","ID":"3NY2V","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"9NGJ8","lineColorHex":"#DC306C","text":"find方法返回第一个满足条件的值，findIndex方法则返回这个值在数组里的索引。如果没有满足条件的值，find会返回undefined，而findIndex返回-1。"},"objectClass":"NSArray"},"text":"find和findindex方法\nfind和findIndex方法接收一个回调函数，搜索一个满足回调函数条件的值。"},"objectClass":"NSArray"},"text":"搜索"},"7":{"objectClass":"MindNode","ID":"7TC56","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7L6YJ","lineColorHex":"#DC306C","text":"如果想把数组里所有元素输出为一个字符串，可以用toString方法。"},"1":{"objectClass":"MindNode","ID":"RE5M5","lineColorHex":"#DC306C","text":"如果想用一个不同的分隔符（比如-）把元素隔开，可以用join方法。"},"objectClass":"NSArray"},"text":"输出数组为字符串"},"objectClass":"NSArray"},"text":"数组：\nJS中得数组是一种特殊对象，用来表示偏移量的索引是该对象的属性。数字索引会被转换成字符串类型，因为JS对象的属性名必须是字符串类型。"},"1":{"objectClass":"MindNode","ID":"11PKM","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1G56K","lineColorHex":"#BF58F5","text":"列表的抽象数据类型定义：\n一些方法。还是使用数组来进行存储。"},"objectClass":"NSArray"},"text":"列表\n计算机程序也在使用列表，尤其是列表中保存的元素不是太多时。当不需要在一个很长的序列中查找元素，或者对其进行排序时，列表显得尤为有用。反之，如果数据结构非常复杂，列表的作用就没有那么大了。"},"2":{"objectClass":"MindNode","ID":"UO4J3","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"3KQ3P","lineColorHex":"#26BBFF","text":"对栈的操作：\n栈内元素只能通过列表的一段访问，称为栈顶，是后入先出的数据结构。对栈的两种主要操作入栈使用push（），出栈使用pop（）方法。peek()方法则只返回栈顶元素，而不删除它。为了记录栈顶元素的位置，同时也为了标记哪里可以加入新元素，使用变量top，当向栈内压入元素时，该变量增大；从栈内弹出元素时，该变量减小。"},"1":{"objectClass":"MindNode","ID":"6PT6G","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"267IJ","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"236PU","lineColorHex":"#26BBFF","text":"//实现push方法\nfunction push(element){\n    //++操作符 非常重要\n    this.dataStore[this.top++] = element;\n}"},"1":{"objectClass":"MindNode","ID":"7PVU8","lineColorHex":"#26BBFF","text":"//实现pop方法\nfunction pop(){\n    return this.dataStore[--this.top];\n}"},"2":{"objectClass":"MindNode","ID":"72D9R","lineColorHex":"#26BBFF","text":"//实现peek方法\nfunction peek() {\n    return this.dataStore[this.top-1];\n}"},"objectClass":"NSArray"},"text":"定义类：\nfunction Stack() {\n    this.dataStore =[];\n    this.top = 0;\n    this.push = push;\n    this.pop = pop;\n    this.peek =ppek;\n}"},"objectClass":"NSArray"},"text":"栈的实现：\n先创建Stack类，然后实现其中的push（）pop（） peek（）方法，并定义基础数据类型为数组，top记录栈顶位置（注意top始终指向的是最后一个元素的下一个位置）"},"2":{"objectClass":"MindNode","ID":"E5Y8P","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"93817","lineColorHex":"#26BBFF","text":"数制之间的转换：\n制。假设想将数字n转换为以b为基数的数字，实现转换的算法如下。\n（1）最高位为n%b，将此位压入栈。\n（2）使用n/b代替n。\n（3）重复步骤1和2，直到n等于0，且没有余数。\n（4）持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。"},"1":{"objectClass":"MindNode","ID":"M63UX","lineColorHex":"#26BBFF","text":"回文：\n我们得到一个回文之后，将其从左至右依次压入栈内，再从栈中取出，字符串刚好与原来的字符串顺序相反，只需要比较这两个字符串是否相等，如果相等就是一个回文。"},"objectClass":"NSArray"},"text":"使用Stack类"},"objectClass":"NSArray"},"text":"栈\n因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现"},"3":{"objectClass":"MindNode","ID":"734RX","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"6OSE0","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"B8344","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"J6388","lineColorHex":"#37C45A","text":"实现类中方法：\nfunction enqueue(element) {\n    //因为有front方法所以不需要操作头指针\n    this.dataStore.push(element);\n}\n\nfunction dequeue(){\n    //因为有back方法所以不需要操作头指针\n    return this.dataStore.shift();\n}\n\nfunction front(){\n    //返回第一个元素\n    return this.dataStore[0];\n}\n\nfunction back(){\n    //返回最后一个元素\n    return this.dataStore[this.dataStore.length-1];\n}\n\n"},"1":{"objectClass":"MindNode","ID":"V8FI8","lineColorHex":"#37C45A","text":"function toString(){\n    //重写toString方法\n    let retStr = \"\";\n    for(let i=0;i<this.dataStore.length;i++){\n        retStr +=this.dataStore[i]+\"\\n\";\n    }\n    return retStr;\n}\n\nfunction empty(){\n    //判断队列是否为空\n    if(this.dataStore.length===0){\n        return true;\n    }else{\n        return false;\n    }\n}"},"objectClass":"NSArray"},"text":"构造函数：\nfunction Queue(){\n    this.dataStore = []; //用数组实现队列\n    this.enqueue = enqueue; //进队方法\n    this.dequeue = dequeue; //出队方法\n    this.front = front; //头指针\n    this.back = back; //尾指针\n    this.toString = toString; \n    this.empty = empty;\n}"},"objectClass":"NSArray"},"text":"实现Queue类："},"1":{"objectClass":"MindNode","ID":"N1HHP","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"C1RN2","lineColorHex":"#37C45A","text":"基数排序法"},"objectClass":"NSArray"},"text":"使用队列对数据进行排序"},"2":{"objectClass":"MindNode","ID":"36J54","lineColorHex":"#37C45A","text":"优先队列\n在一般情况下，从队列中删除的元素，一定是率先入队的元素。但是也有一些使用队列的应用，在删除元素时不必遵守先进先出的约定"},"objectClass":"NSArray"},"text":"队列\n队列只能在队尾插入元素，在队首删除元素，先进先出。"},"4":{"objectClass":"MindNode","ID":"VQ878","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"KJ126","lineColorHex":"#1BD6E7","text":"数组的缺点：\n在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再要加入新的元素就会非常困难。在数组中，添加和删除元素也很麻烦，因为需要将数组中的其他元素向前或向后平移，以反映数组刚刚进行了添加或删除操作。然而，JavaScript的数组并不存在上述问题，因为使用splice()方法不需要再访问数组中的其他元素了。\n\nJS的缺点是被实现成了对象，如果需要随机访问，数组仍是最好的选择。"},"1":{"objectClass":"MindNode","ID":"L5BP7","lineColorHex":"#1BD6E7","text":"定义链表：\n链表是由一组节点组成的集合，每个节点使用一个对象的引用指向后继节点。"},"2":{"objectClass":"MindNode","ID":"FR9QL","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"A0Y5A","lineColorHex":"#1BD6E7","text":"Node类：\nfunction Node(element){\n    //element用来保存节点上的数据\n    this.element = element;\n    //next用来保存指向下一个节点的链接\n    this.next = null;\n}"},"1":{"objectClass":"MindNode","ID":"603PS","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"884G6","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"36F5T","lineColorHex":"#1BD6E7","text":"辅助方法find（item）：\nfunction find(item){\n    let currNode = this.head;\n    while(currNode.element != item){\n        currNode = currNode.next;\n    }\n    return currNode;\n}\n\nitem是我们需要找到的节点，创建一个引用指向链表的头节点（this.head就是调用该方法的链表的头节点）循环链表找到节点并返回。"},"objectClass":"NSArray"},"text":"插入节点：\nfunction insert(newElement,item){\n    let newNode = new Node(newElement);\n    let current = this.find(item);\n    newNode.next = current.next;\n    current.net = newNode;\n}\n首先创建新节点，然后再通过辅助函数find找到要插入的节点，将新节点的next指向被插入节点的下一节点，被插入节点的next指向新节点。"},"1":{"objectClass":"MindNode","ID":"N62ZF","lineColorHex":"#1BD6E7","text":"显式链表的元素：\nfunction display(){\n    let currNode = this.head;\n    while(!(currNode.next ===null)){\n        print(currNode.next.element);\n        currNode = currNode.next;\n    }\n}"},"2":{"objectClass":"MindNode","ID":"38BCK","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"3N3M0","lineColorHex":"#1BD6E7","text":"findPrevious（）找到待删除的前一个节点：\nfunction findPrevious(item){\n    let currNode = this.head;\n    while(!(currNode.next === null)&&(currNode.next.element !==item)){\n        currNode = currNode.next;\n    }\n    return currNode;\n}"},"objectClass":"NSArray"},"text":"删除节点：\n从链表中删除节点时，需要先找到待删除节点前面的节点。找到这个节点后，修改它的next属性，使其不再指向待删除节点，而是指向待删除节点的下一个节点。\n\nfunction remove(item){\n    let preNode = this.findPrevious(item);\n    if(!(preNode.next ===null))\n        preNode.next = preNode.next.next;\n}"},"objectClass":"NSArray"},"text":"function LinkedList(){\n    //使用Node对象来保存链表的头节点\n    this.head = new Node(\"head\");\n    this.find = find;\n    this.insert = insert;\n    this.remove = remove;\n    this.display = display;\n}\n\nLinkedList类只有一个属性那就是使用Node对象保存链表的头节点。其他的都是该类的方法。"},"objectClass":"NSArray"},"text":"设计一个基于对象的链表：\n需要两个类，Node类表示节点，Linkedlist类提供插入节点、删除节点、显示列表元素的方法和一些其他方法。"},"3":{"objectClass":"MindNode","ID":"6DP6M","lineColorHex":"#1BD6E7","text":"双向链表"},"4":{"objectClass":"MindNode","ID":"CTH26","lineColorHex":"#1BD6E7","text":"循环链表"},"5":{"objectClass":"MindNode","ID":"62M33","lineColorHex":"#1BD6E7","text":"链表的其他方法"},"objectClass":"NSArray"},"text":"链表"},"5":{"objectClass":"MindNode","ID":"8255F","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"7Q720","lineColorHex":"#FFC700","text":""},"objectClass":"NSArray"},"text":"字典\n一种以键值对形式存储数据的数据结构"},"objectClass":"NSArray"},"text":"JS数据结构"},"ID":"4C32M","style":100}